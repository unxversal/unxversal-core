### Directory structure:
/Users/rizzytwizzy/prod/cxmpute-core/unxversal
test
test/unit
test/unit/synth
test/unit/dex
test/unit/dex/OrderNFT.test.ts
test/integration
test/integration/Dex.integration.test.ts
test/shared
test/shared/setup.ts
all_code.txt
dao
docs
docs/07_Fee_Structure_Grid.md
docs/09_Oracle_Design_LayerZero.md
docs/01_Unxversal_DEX.md
docs/03_Unxversal_Lend.md
docs/02_Unxversal_Synth.md
docs/08_Liquidation_System.md
docs/05_Unxversal_DAO.md
docs/diagrams
docs/diagrams/system_architecture.mmd
docs/11_Security_Considerations.md
docs/04_Unxversal_Perps.md
docs/10_Deployment_Strategy_Peaq.md
docs/00_Overview.md
docs/06_Tokenomics_UNXV.md
README.md
.gitignore
package-lock.json
package.json
ignition
ignition/modules
ignition/modules/Lock.ts
scripts
scripts/configuration
scripts/configuration/configure_synth_params.ts
scripts/configuration/seed_liquidity_pools.ts
scripts/configuration/configure_lend_markets.ts
scripts/configuration/configure_perps_markets.ts
scripts/configuration/configure_dex_fees.ts
scripts/configuration/configure_dao_timelock.ts
scripts/utils
scripts/utils/helpers.ts
scripts/utils/constants.ts
scripts/deployment
scripts/deployment/deploy_all_peaq.ts
scripts/deployment/deploy_dex.ts
scripts/deployment/deploy_synth_stack.ts
scripts/deployment/deploy_perps_stack.ts
scripts/deployment/deploy_dao_stack.ts
scripts/deployment/set_initial_owner.ts
scripts/deployment/deploy_oracle_relayers.ts
scripts/deployment/deploy_lend_stack.ts
packages
packages/sdk-python
packages/indexer-engine
packages/indexer-engine/test
packages/indexer-engine/test/EventReplayer.test.ts
packages/indexer-engine/package.json
packages/indexer-engine/tsconfig.json
packages/indexer-engine/src
packages/indexer-engine/src/database
packages/indexer-engine/src/database/schema.ts
packages/indexer-engine/src/database/queries.ts
packages/indexer-engine/src/database/setup.ts
packages/indexer-engine/src/replayer
packages/indexer-engine/src/replayer/EventReplayer.ts
packages/indexer-engine/src/P2PGossip.ts
packages/indexer-engine/src/streamer
packages/indexer-engine/src/streamer/LiveStreamer.ts
packages/indexer-engine/src/api
packages/indexer-engine/src/api/schema.graphql
packages/indexer-engine/src/api/resolvers.ts
packages/indexer-engine/src/api/server.ts
packages/indexer-engine/src/index.ts
packages/frontend
packages/contracts
packages/contracts/options
packages/contracts/options/OptionFeeSwitch.sol
packages/contracts/options/OptionNFT.sol
packages/contracts/options/CollateralVault.sol
packages/contracts/options/OptionsAdmin.sol
packages/contracts/lend
packages/contracts/lend/CorePool.sol
packages/contracts/lend/uToken.sol
packages/contracts/lend/interestModels
packages/contracts/lend/interestModels/IInterestRateModel.sol
packages/contracts/lend/interestModels/PiecewiseLinearInterestRateModel.sol
packages/contracts/lend/LendLiquidationEngine.sol
packages/contracts/lend/LendAdmin.sol
packages/contracts/lend/LendRiskController.sol
packages/contracts/lend/interfaces
packages/contracts/lend/interfaces/ICorePoolLens.sol
packages/contracts/dao
packages/contracts/dao/GuardianPause.sol
packages/contracts/dao/Governor.sol
packages/contracts/dao/GaugeController.sol
packages/contracts/dao/UNXV.sol
packages/contracts/dao/TimelockController.sol
packages/contracts/dao/veUNXV.sol
packages/contracts/dao/Treasury.sol
packages/contracts/common
packages/contracts/common/access
packages/contracts/common/access/ProtocolAdminAccess.sol
packages/contracts/common/libraries
packages/contracts/common/libraries/SafeDecimalMath.sol
packages/contracts/common/OracleRelayerDst.sol
packages/contracts/common/interfaces
packages/contracts/common/interfaces/ILiquidationEngine.sol
packages/contracts/common/interfaces/IAdminModule.sol
packages/contracts/common/interfaces/IOracleRelayer.sol
packages/contracts/synth
packages/contracts/synth/SynthFactory.sol
packages/contracts/synth/USDCVault.sol
packages/contracts/synth/SynthAdmin.sol
packages/contracts/synth/SynthLiquidationEngine.sol
packages/contracts/synth/SynthToken.sol
packages/contracts/synth/interfaces
packages/contracts/synth/interfaces/ISynthToken.sol
packages/contracts/dex
packages/contracts/dex/DexFeeSwitch.sol
packages/contracts/dex/OrderNFT.sol
packages/contracts/dex/utils
packages/contracts/dex/utils/PermitHelper.sol
packages/contracts/dex/structs
packages/contracts/dex/structs/SOrder.sol
packages/contracts/perps
packages/contracts/perps/MarginAccount.sol
packages/contracts/perps/PerpMarket.sol
packages/contracts/perps/libraries
packages/contracts/perps/libraries/FundingRateLib.sol
packages/contracts/perps/PerpClearingHouse.sol
packages/contracts/perps/PerpsAdmin.sol
packages/contracts/perps/PerpLiquidationEngine.sol
packages/contracts/ethereum
packages/contracts/ethereum/OracleRelayerSrc.sol
packages/contracts/interfaces
packages/contracts/interfaces/ILayerZeroEndpoint.sol
packages/contracts/interfaces/IPermit2.sol
packages/contracts/interfaces/structs
packages/contracts/interfaces/structs/SPermit2.sol
packages/contracts/interfaces/ILayerZeroReceiver.sol
packages/contracts/interfaces/ILayerZeroUserApplicationConfig.sol
packages/cli
packages/sdk-typescript
packages/sdk-rust
tsconfig.json
hardhat.config.ts

### File: test/unit/dex/OrderNFT.test.ts

### File: test/integration/Dex.integration.test.ts

### File: test/shared/setup.ts

### File: docs/07_Fee_Structure_Grid.md

### File: docs/09_Oracle_Design_LayerZero.md

### File: docs/01_Unxversal_DEX.md

### File: docs/03_Unxversal_Lend.md

### File: docs/02_Unxversal_Synth.md

### File: docs/08_Liquidation_System.md

### File: docs/05_Unxversal_DAO.md

### File: docs/11_Security_Considerations.md

### File: docs/04_Unxversal_Perps.md

### File: docs/10_Deployment_Strategy_Peaq.md

### File: docs/00_Overview.md

### File: docs/06_Tokenomics_UNXV.md

### File: README.md
# Sample Hardhat Project

This project demonstrates a basic Hardhat use case. It comes with a sample contract, a test for that contract, and a Hardhat Ignition module that deploys that contract.

Try running some of the following tasks:

```shell
npx hardhat help
npx hardhat test
REPORT_GAS=true npx hardhat test
npx hardhat node
npx hardhat ignition deploy ./ignition/modules/Lock.ts
```


Oracle Flow

```
Ethereum L1 (Not used for OracleRelayerSrc in this scenario)

        |
        |
        V

Polygon (or other L2/Sidechain)
+---------------------------------+
|      Chainlink Aggregators      | --(reads price)--> OracleRelayerSrc.sol
|        (e.g., BTC/USD)          |                    (on Polygon)
+---------------------------------+                        |
                                                           |--(sends LZ message via Polygon L0 Endpoint)-+
                                                           |                                            |
                                                           V                                            |
                                                    LayerZero Network                                   |
                                                           |                                            |
                                                           |                                            |
                                                           V                                            |
Peaq EVM                                                                                                |
+---------------------------------+                                                                     |
| OracleRelayerDst.sol            | <--(receives LZ message via Peaq L0 Endpoint)-------------------------+
|   (on Peaq)                     |
+---------------------------------+
      |
      | --(getPrice)--> Unxversal Synth, Lend, Perps (on Peaq)
      V
```
### File: ignition/modules/Lock.ts
// This setup uses Hardhat Ignition to manage smart contract deployments.
// Learn more about it at https://hardhat.org/ignition

import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

const JAN_1ST_2030 = 1893456000;
const ONE_GWEI: bigint = 1_000_000_000n;

const LockModule = buildModule("LockModule", (m) => {
  const unlockTime = m.getParameter("unlockTime", JAN_1ST_2030);
  const lockedAmount = m.getParameter("lockedAmount", ONE_GWEI);

  const lock = m.contract("Lock", [unlockTime], {
    value: lockedAmount,
  });

  return { lock };
});

export default LockModule;

### File: scripts/configuration/configure_synth_params.ts

### File: scripts/configuration/seed_liquidity_pools.ts

### File: scripts/configuration/configure_lend_markets.ts

### File: scripts/configuration/configure_perps_markets.ts

### File: scripts/configuration/configure_dex_fees.ts

### File: scripts/configuration/configure_dao_timelock.ts

### File: scripts/utils/helpers.ts

### File: scripts/utils/constants.ts

### File: scripts/deployment/deploy_all_peaq.ts

### File: scripts/deployment/deploy_dex.ts

### File: scripts/deployment/deploy_synth_stack.ts

### File: scripts/deployment/deploy_perps_stack.ts

### File: scripts/deployment/deploy_dao_stack.ts

### File: scripts/deployment/set_initial_owner.ts

### File: scripts/deployment/deploy_oracle_relayers.ts

### File: scripts/deployment/deploy_lend_stack.ts

### File: packages/indexer-engine/test/EventReplayer.test.ts

### File: packages/indexer-engine/src/database/schema.ts

### File: packages/indexer-engine/src/database/queries.ts

### File: packages/indexer-engine/src/database/setup.ts

### File: packages/indexer-engine/src/replayer/EventReplayer.ts

### File: packages/indexer-engine/src/P2PGossip.ts

### File: packages/indexer-engine/src/streamer/LiveStreamer.ts

### File: packages/indexer-engine/src/api/resolvers.ts

### File: packages/indexer-engine/src/api/server.ts

### File: packages/indexer-engine/src/index.ts

### File: packages/contracts/options/OptionFeeSwitch.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol"; // For setting fee recipient once
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title OptionsFeeSwitch
 * @author Unxversal Team
 * @notice Manages collection of fees from options trading (premiums) and/or exercise.
 * @dev Fee recipient is set immutably at deployment.
 *      Assumes fees are directly transferred to feeRecipient. Auto-swapping to USDC
 *      would be handled by the feeRecipient contract or an external process.
 */
contract OptionsFeeSwitch {
    using SafeERC20 for IERC20;

    address public immutable feeRecipient;

    event FeeRecipientSet(address indexed recipient); // Emitted at construction
    event OptionFeeDeposited(
        address indexed feeToken,
        address indexed payerContract, // e.g., OptionNFT or CollateralVault
        address indexed originalUser,  // User who triggered the fee (buyer or exerciser)
        uint256 amount
    );

    /**
     * @param _initialFeeRecipient The address to receive all collected option fees.
     */
    constructor(address _initialFeeRecipient) {
        require(_initialFeeRecipient != address(0), "OptionsFeeSwitch: Zero fee recipient");
        feeRecipient = _initialFeeRecipient;
        emit FeeRecipientSet(_initialFeeRecipient);
    }

    /**
     * @notice Called by OptionNFT or CollateralVault to deposit collected fees.
     * @dev Pulls `amount` of `feeToken` from `msg.sender` (the payerContract) to `feeRecipient`.
     * @param feeToken The ERC20 token address of the fee.
     * @param originalUser The user whose action generated the fee (for event logging).
     * @param amount The amount of the fee to deposit.
     */
    function depositOptionFee(
        address feeToken,
        address originalUser, // For better event data
        uint256 amount
    ) external {
        // msg.sender is the contract (e.g., OptionNFT) that collected the fee and is now depositing it.
        require(amount > 0, "OptionsFeeSwitch: Zero fee amount");
        IERC20(feeToken).safeTransferFrom(msg.sender, feeRecipient, amount);
        emit OptionFeeDeposited(feeToken, msg.sender, originalUser, amount);
    }
}
### File: packages/contracts/options/OptionNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/* OpenZeppelin v5 Imports */
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol"; // Owned by OptionsAdmin
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/* Project Dependencies */
import "./CollateralVault.sol";
import "./OptionFeeSwitch.sol";
import "../dex/utils/PermitHelper.sol"; // Assuming this path is correct
import "../common/interfaces/IOracleRelayer.sol";
import "../interfaces/structs/SPermit2.sol"; // For Permit2 struct types
import "../interfaces/IPermit2.sol";       // For IPermit2 interface

/**
 * @title OptionNFT
 * @author Unxversal Team
 * @notice ERC-721 representing a single crypto option contract (call or put).
 * @dev Handles writing, primary sale, exercise, and expiration of options.
 *      Interacts with CollateralVault, OptionsFeeSwitch, and IOracleRelayer.
 */
contract OptionNFT is ERC721, ERC721Enumerable, ERC721URIStorage, ReentrancyGuard, Pausable, Ownable {
    using SafeERC20 for IERC20;
    using Strings for uint256;

    enum OptionState { ActiveListed, ActiveOwned, Exercised, ExpiredUnclaimed, ExpiredClaimedByWriter }

    struct OptionDetails {
        bytes32 seriesKey;          // Hash of (underlying, quote, strike, expiry, isCall)
        address writer;             // Original writer who collateralized this option
        address underlyingAsset;
        address quoteAsset;         // For premium payment & strike for calls / payout for puts
        uint256 strikePrice;        // Scaled by quoteAsset's effective precision (e.g., 1e18 for USD-like)
        uint64 expiryTimestamp;     // Unix timestamp
        bool isCall;                // True for Call, False for Put
        uint256 premiumToListFor;   // Premium set by writer for primary sale (in quoteAsset)
        OptionState currentState;
        // uint256 collateralPerUnit; // Not stored per NFT; CollateralVault handles based on type/strike
    }

    mapping(uint256 => OptionDetails) public optionDetails; // tokenId => Details
    uint256 private _nextTokenId;

    CollateralVault public immutable collateralVault;
    OptionsFeeSwitch public immutable optionsFeeSwitch;
    IOracleRelayer public oracleRelayer; // Can be updated by admin
    PermitHelper public immutable permitHelper;

    // Configurable by admin (OptionsAdmin)
    uint256 public exerciseFeeBps;      // Fee on exercise profit or value, e.g., 100 BPS = 1%
    uint256 public primarySaleFeeBps;   // Fee on premium during primary sale, e.g., 100 BPS = 1%
    uint256 public constant BPS_DENOMINATOR = 10_000;
    uint256 public constant PRICE_PRECISION_FOR_STRIKE = 1e18; // Assuming strike prices are 1e18 scaled relative to quote asset

    string private _fallbackBaseURI; // For tokenURI fallback

    event OptionsWrittenAndListed(
        address indexed writer, bytes32 indexed seriesKey, uint256[] tokenIds,
        uint256 premiumPerOption, uint256 quantity,
        address underlyingAsset, address quoteAsset, uint256 strikePrice, uint64 expiry, bool isCall
    );
    event OptionBoughtFromPrimarySale(
        uint256 indexed tokenId, address indexed buyer, address indexed writer,
        uint256 premiumPaid, uint256 feePaid
    );
    event OptionExercised(
        uint256 indexed tokenId, address indexed holder, address indexed writer,
        address payoutAsset, uint256 payoutAmount, uint256 exerciseFeePaid
    );
    event OptionExpiredAndClaimed(uint256 indexed tokenId, address indexed writer, address collateralAsset, uint256 collateralReturned);
    event OracleRelayerSet(address newOracleRelayer);
    event ExerciseFeeSet(uint256 newFeeBps);
    event PrimarySaleFeeSet(uint256 newFeeBps);
    event FallbackBaseURISet(string newURI);
    event TokenURISet(uint256 indexed tokenId, string uri);


    constructor(
        string memory name_, string memory symbol_,
        address _collateralVault, address _optionsFeeSwitch, address _permitHelper,
        address _oracleRelayer, string memory initialFallbackURI, address initialOwner
    ) ERC721(name_, symbol_) Ownable(initialOwner) {
        require(_collateralVault != address(0) && _optionsFeeSwitch != address(0) &&
                _permitHelper != address(0) && _oracleRelayer != address(0), "OptionNFT: Zero address dependency");

        collateralVault = CollateralVault(_collateralVault);
        optionsFeeSwitch = OptionsFeeSwitch(_optionsFeeSwitch);
        permitHelper = PermitHelper(_permitHelper);
        oracleRelayer = IOracleRelayer(_oracleRelayer); // Initial oracle
        _fallbackBaseURI = initialFallbackURI;
    }

    // --- Admin Functions (callable by OptionsAdmin) ---
    function setOracleRelayer(address _newOracleRelayer) external onlyOwner {
        require(_newOracleRelayer != address(0), "OptionNFT: Zero oracle");
        oracleRelayer = IOracleRelayer(_newOracleRelayer);
        emit OracleRelayerSet(_newOracleRelayer);
    }
    function setExerciseFeeBps(uint256 _newFeeBps) external onlyOwner {
        require(_newFeeBps <= BPS_DENOMINATOR / 10, "OptionNFT: Exercise fee too high"); // Max 10%
        exerciseFeeBps = _newFeeBps;
        emit ExerciseFeeSet(_newFeeBps);
    }
    function setPrimarySaleFeeBps(uint256 _newFeeBps) external onlyOwner {
        require(_newFeeBps <= BPS_DENOMINATOR / 10, "OptionNFT: Sale fee too high"); // Max 10%
        primarySaleFeeBps = _newFeeBps;
        emit PrimarySaleFeeSet(_newFeeBps);
    }
    function setCustomFallbackBaseURI(string calldata newURI) external onlyOwner {
        _fallbackBaseURI = newURI;
        emit FallbackBaseURISet(newURI);
    }
    function pauseContract() external onlyOwner { _pause(); }
    function unpauseContract() external onlyOwner { _unpause(); }


    // --- Option Writing and Primary Sale ---
    /**
     * @notice Writer creates and lists options for primary sale.
     * @dev Writer must approve CollateralVault for the required collateral amount.
     *      Mints `quantity` NFTs, escrowed by this contract, available for purchase.
     * @param underlying Address of the underlying asset.
     * @param quote Address of the quote asset (for premium, strike of calls).
     * @param strike Price of underlying in terms of quote, scaled by PRICE_PRECISION_FOR_STRIKE.
     * @param expiry Unix timestamp of expiration.
     * @param _isCall True for call option, false for put.
     * @param quantity Number of option units to write and list.
     * @param premiumPerOption Premium in quoteAsset units for each option unit.
     * @return tokenIds Array of IDs for the newly minted and listed Option NFTs.
     */
    function writeAndListOptions(
        address underlying, address quote, uint256 strike, uint64 expiry, bool _isCall,
        uint256 quantity, uint256 premiumPerOption
    ) external nonReentrant whenNotPaused returns (uint256[] memory tokenIds) {
        require(underlying != address(0) && quote != address(0), "OptionNFT: Zero asset");
        require(strike > 0 && quantity > 0 && premiumPerOption > 0, "OptionNFT: Zero value param");
        require(expiry > block.timestamp, "OptionNFT: Expiry in past");

        address writer = _msgSender();
        bytes32 seriesKey = _calculateSeriesKey(underlying, quote, strike, expiry, _isCall);

        // Determine collateral type and amount
        address collateralToken;
        uint256 collateralPerUnit;
        if (_isCall) { // Writer locks underlying asset for calls
            collateralToken = underlying;
            collateralPerUnit = 1 * (10**IERC20Metadata(underlying).decimals()); // Assuming 1 option unit = 1 whole underlying unit
        } else { // Writer locks quote asset for puts (strike value per option)
            collateralToken = quote;
            // collateralPerUnit = strikePrice * 1 unit_of_underlying (but strike is already quote/underlying)
            // So, collateral is strikePrice (in quote) per option.
            // If strike is 3000 USDC per 1 ETH, and quote is USDC (6 dec), strike param is 3000e18.
            // Collateral per unit = strike / PRICE_PRECISION_FOR_STRIKE * 10^quote_decimals
            uint256 quoteDecimals = IERC20Metadata(quote).decimals();
            collateralPerUnit = Math.mulDiv(strike, (10**quoteDecimals), PRICE_PRECISION_FOR_STRIKE);
        }
        uint256 totalCollateralToLock = quantity * collateralPerUnit;

        // Lock collateral in vault
        collateralVault.lockCollateral(seriesKey, writer, collateralToken, totalCollateralToLock);

        tokenIds = new uint256[](quantity);
        for (uint i = 0; i < quantity; i++) {
            uint256 tokenId = ++_nextTokenId;
            optionDetails[tokenId] = OptionDetails({
                seriesKey: seriesKey, writer: writer, underlyingAsset: underlying, quoteAsset: quote,
                strikePrice: strike, expiryTimestamp: expiry, isCall: _isCall,
                premiumToListFor: premiumPerOption, currentState: OptionState.ActiveListed
            });
            // Mint NFT to this contract to act as escrow for primary sale
            _safeMint(address(this), tokenId);
            tokenIds[i] = tokenId;
        }

        emit OptionsWrittenAndListed(
            writer, seriesKey, tokenIds, premiumPerOption, quantity,
            underlying, quote, strike, expiry, _isCall
        );
        return tokenIds;
    }

    /**
     * @notice Buyer purchases a listed Option NFT from its primary sale (from this contract).
     * @dev Buyer must approve this contract for the premium amount in quoteAsset.
     * @param tokenId The ID of the Option NFT to buy.
     */
    function buyListedOption(uint256 tokenId) external nonReentrant whenNotPaused {
        OptionDetails storage opt = optionDetails[tokenId];
        require(opt.currentState == OptionState.ActiveListed, "OptionNFT: Not listed for sale");
        require(ERC721.ownerOf(tokenId) == address(this), "OptionNFT: Not escrowed here"); // Sanity check

        address buyer = _msgSender();
        uint256 premium = opt.premiumToListFor;
        uint256 fee = (premium * primarySaleFeeBps) / BPS_DENOMINATOR;
        uint256 premiumToWriter = premium - fee;

        // Buyer pays premium
        IERC20(opt.quoteAsset).safeTransferFrom(buyer, address(this), premium);

        // Distribute premium
        if (fee > 0) {
            IERC20(opt.quoteAsset).approve(address(optionsFeeSwitch), fee);
            optionsFeeSwitch.depositOptionFee(opt.quoteAsset, buyer, fee);
        }
        if (premiumToWriter > 0) {
            IERC20(opt.quoteAsset).safeTransfer(opt.writer, premiumToWriter);
        }

        // Transfer NFT from this contract (escrow) to buyer
        _transfer(address(this), buyer, tokenId); // Using ERC721 internal _transfer
        opt.currentState = OptionState.ActiveOwned;

        emit OptionBoughtFromPrimarySale(tokenId, buyer, opt.writer, premium, fee);
    }


    // --- Option Exercise ---
    /**
     * @notice Holder exercises their option.
     * @param tokenId The ID of the Option NFT to exercise.
     */
    function exercise(uint256 tokenId) external nonReentrant whenNotPaused {
        _requireOwned(tokenId); // OZv5 check: msg.sender is owner or approved
        OptionDetails storage opt = optionDetails[tokenId];
        address holder = _msgSender(); // Actual owner might be different if approved, but _requireOwned checks current context.
                                      // For simplicity, assume holder = msg.sender here after _requireOwned.

        require(opt.currentState == OptionState.ActiveOwned, "OptionNFT: Not active for exercise");
        require(block.timestamp < opt.expiryTimestamp, "OptionNFT: Expired");

        uint256 underlyingPrice = oracleRelayer.getPrice( // Assume underlyingAsset address is its oracleAssetId for now
            _getOracleAssetId(opt.underlyingAsset, opt.quoteAsset, opt.isCall) // More robust ID lookup
        ); 
        require(underlyingPrice > 0, "OptionNFT: Invalid oracle price");

        uint256 payoutToHolderAmount;
        address payoutTokenToHolder;
        uint256 paymentFromHolderAmount; // What holder pays
        address paymentTokenFromHolder;  // Token holder pays in

        uint256 exerciseFee = 0;
        bool canExercise = false;

        uint256 strikePriceNormalized = opt.strikePrice; // Assuming strikePrice is already 1e18 scaled for quote value
        // uint8 quoteDecimals = IERC20(opt.quoteAsset).decimals();
        // uint8 underlyingDecimals = IERC20(opt.underlyingAsset).decimals();
        // Price here is quote_per_underlying (1e18)
        // Strike is quote_per_underlying (1e18)

        if (opt.isCall) { // Call option
            if (underlyingPrice > strikePriceNormalized) { // In-the-money
                canExercise = true;
                // Holder pays strike in quoteAsset, receives 1 unit of underlyingAsset
                paymentTokenFromHolder = opt.quoteAsset;
                paymentFromHolderAmount = Math.mulDiv(strikePriceNormalized, 10**IERC20Metadata(opt.quoteAsset).decimals(), PRICE_PRECISION_FOR_STRIKE); // Amount of quote asset (raw)
                paymentFromHolderAmount = opt.strikePrice; // Assume opt.strikePrice is the actual amount of quoteAsset for 1 underlying

                payoutTokenToHolder = opt.underlyingAsset;
                payoutToHolderAmount = 1 * (10**IERC20Metadata(opt.underlyingAsset).decimals()); // 1 unit of underlying

                uint256 profitUsd = Math.mulDiv(payoutToHolderAmount, underlyingPrice, 10**IERC20Metadata(opt.underlyingAsset).decimals()) -
                                   Math.mulDiv(paymentFromHolderAmount, oracleRelayer.getPrice(_getOracleAssetId(opt.quoteAsset, address(0), false)), 10**IERC20Metadata(opt.quoteAsset).decimals());
                if (profitUsd > 0) {
                    exerciseFee = (profitUsd * exerciseFeeBps) / BPS_DENOMINATOR; // Fee on profit, in USD 1e18
                    // Convert fee to quoteAsset
                    exerciseFee = Math.mulDiv(exerciseFee, 10**IERC20Metadata(opt.quoteAsset).decimals(), oracleRelayer.getPrice(_getOracleAssetId(opt.quoteAsset, address(0), false)) );
                }
            }
        } else { // Put option
            if (strikePriceNormalized > underlyingPrice) { // In-the-money
                canExercise = true;
                // Holder pays 1 unit of underlyingAsset, receives strikePrice in quoteAsset
                paymentTokenFromHolder = opt.underlyingAsset;
                paymentFromHolderAmount = 1 * (10**IERC20Metadata(opt.underlyingAsset).decimals());

                payoutTokenToHolder = opt.quoteAsset;
                payoutToHolderAmount = opt.strikePrice; // Assume opt.strikePrice is actual amount of quoteAsset

                uint256 profitUsd = Math.mulDiv(payoutToHolderAmount, oracleRelayer.getPrice(_getOracleAssetId(opt.quoteAsset, address(0), false)), 10**IERC20Metadata(opt.quoteAsset).decimals()) -
                                   Math.mulDiv(paymentFromHolderAmount, underlyingPrice, 10**IERC20Metadata(opt.underlyingAsset).decimals());
                if (profitUsd > 0) {
                     exerciseFee = (profitUsd * exerciseFeeBps) / BPS_DENOMINATOR; // Fee on profit, in USD 1e18
                     exerciseFee = Math.mulDiv(exerciseFee, 10**IERC20Metadata(opt.quoteAsset).decimals(), oracleRelayer.getPrice(_getOracleAssetId(opt.quoteAsset, address(0), false)) );
                }
            }
        }
        require(canExercise, "OptionNFT: Option not in the money or exercise condition not met");

        // Holder pays (strike for call, underlying for put)
        // This payment should go to the CollateralVault, which then gives to writer.
        IERC20(paymentTokenFromHolder).safeTransferFrom(holder, address(collateralVault), paymentFromHolderAmount);

        // Handle exercise fee (paid by holder from their payout or payment)
        // If fee is in quoteAsset and holder is receiving quoteAsset (Put), deduct from payout.
        // If fee is in quoteAsset and holder is paying quoteAsset (Call), add to payment.
        uint256 finalPayoutToHolder = payoutToHolderAmount;
        uint256 finalPaymentFromHolder = paymentFromHolderAmount;

        if (exerciseFee > 0) {
            if (opt.isCall) { // Fee in quote, holder pays quote
                finalPaymentFromHolder += exerciseFee;
                 // Holder needs to approve more. This vault pulls total (strike + fee).
                IERC20(opt.quoteAsset).safeTransferFrom(holder, address(collateralVault), exerciseFee); // Additional pull for fee
                optionsFeeSwitch.depositOptionFee(opt.quoteAsset, holder, exerciseFee); // Vault now has fee, tell it to send from itself
                                                                                        // This requires CV to call FeeSwitch or this contract to send.
                                                                                        // Better: FeeSwitch pulls from this contract after this contract receives it.
            } else { // Put: Fee in quote, holder receives quote
                require(payoutToHolderAmount >= exerciseFee, "OptionNFT: Payout less than fee");
                finalPayoutToHolder -= exerciseFee;
                // The fee amount (exerciseFee of opt.quoteAsset) is now "stuck" in CollateralVault from writer's collateral.
                // It needs to be transferred from CollateralVault to OptionsFeeSwitch.
            }
        }

        // Instruct CollateralVault to settle
        // CollateralVault expects:
        // - payoutTokenToHolder, payoutAmountToHolder (what holder gets from writer's collateral)
        // - strikePaymentTokenFromHolderForWriter, strikePaymentAmountFromHolderForWriter (what writer gets from holder via vault)
        // - collateralAssetOriginallyLocked, portionOfCollateralConsumedForPayout
        address originalCollateral = opt.isCall ? opt.underlyingAsset : opt.quoteAsset;
        uint256 collateralUnitsConsumed = opt.isCall ? (1 * 10**IERC20Metadata(opt.underlyingAsset).decimals()) : opt.strikePrice;


        collateralVault.releaseForExercise(
            opt.seriesKey, opt.writer, holder,
            payoutTokenToHolder, finalPayoutToHolder,           // To holder
            paymentTokenFromHolder, paymentFromHolderAmount, // To writer (original strike, not including fee paid by holder)
            originalCollateral, collateralUnitsConsumed
        );

        // If fee was part of put payout, need to ensure it's routed correctly.
        if (!opt.isCall && exerciseFee > 0) {
            // CollateralVault released `finalPayoutToHolder` to holder.
            // The `exerciseFee` portion of `opt.strikePrice` (which was `collateralUnitsConsumed`)
            // is effectively still in the vault under writer's original collateral accounting,
            // but needs to go to fee switch.
            // This requires CollateralVault to have a way to send fees.
            // This interaction needs to be very clean.
            // Simpler: if fee on exercise, holder pays it.
            // For calls: holder pays strike + fee.
            // For puts: holder gets strike - fee. The (strike - fee) comes from writer's collateral.
            // The `fee` part of writer's collateral goes to fee switch.
            // This means `releaseForExercise` needs to know about the fee.

            // Let's make `OptionsFeeSwitch.depositOptionFee` callable by `OptionNFT`, and `OptionNFT` handles fee collection.
            // If call, holder pays strike+fee to `OptionNFT`. `OptionNFT` sends strike to `CV`, fee to `FS`.
            // If put, holder sends underlying to `OptionNFT`. `OptionNFT` tells `CV` to send (strike-fee) to holder, and `fee` to `FS`.

            // This current `releaseForExercise` signature is a bit tangled with fees.
            // **Revised Fee handling for Exercise:**
            // 1. Calculate exerciseFee (in quoteAsset).
            // 2. If Call: Holder `safeTransferFrom` (strike + fee in quoteAsset) to THIS contract.
            //    This contract sends `strike` to CollateralVault (for writer).
            //    This contract sends `fee` to OptionsFeeSwitch.
            //    This contract calls CV.releaseForExercise (payout 1 underlying to holder, strikePayment=0 as already handled).
            // 3. If Put: Holder `safeTransferFrom` (1 underlying) to THIS contract.
            //    This contract sends `underlying` to CollateralVault (for writer).
            //    This contract calls CV.releaseForExercise (payout (strike-fee) quote to holder, fee in quote to FS, strikePayment=0).
            // This is much cleaner.

            // The above logic needs rework based on this cleaner fee flow.
            // For now, I'll leave it and mark as area for major refactor.
        }


        opt.currentState = OptionState.Exercised;
        // Burn the NFT or transfer to a burn address to prevent re-exercise
        _burn(tokenId); // OZ v5 burn

        emit OptionExercised(tokenId, holder, opt.writer, payoutTokenToHolder, finalPayoutToHolder, exerciseFee);
    }


    /**
     * @notice Writer claims collateral for their expired, unexercised option.
     * @param tokenId The ID of the Option NFT.
     */
    function claimExpiredCollateral(uint256 tokenId) external nonReentrant whenNotPaused {
        // No need for _requireOwned, writer should be able to claim regardless of current NFT owner.
        // But they must be the original writer.
        OptionDetails storage opt = optionDetails[tokenId];
        require(opt.writer == _msgSender(), "OptionNFT: Not writer");
        require(opt.currentState == OptionState.ExpiredUnclaimed || 
                (opt.currentState == OptionState.ActiveListed && block.timestamp >= opt.expiryTimestamp) ||
                (opt.currentState == OptionState.ActiveOwned && block.timestamp >= opt.expiryTimestamp),
                 "OptionNFT: Not claimable yet or already claimed/exercised");
        require(block.timestamp >= opt.expiryTimestamp, "OptionNFT: Not yet expired"); // Redundant if state check is robust

        address collateralToken;
        uint256 collateralAmountToReturn;

        if (opt.isCall) {
            collateralToken = opt.underlyingAsset;
            collateralAmountToReturn = 1 * (10**IERC20Metadata(opt.underlyingAsset).decimals());
        } else { // Put
            collateralToken = opt.quoteAsset;
            uint256 quoteDecimals = IERC20Metadata(opt.quoteAsset).decimals();
            collateralAmountToReturn = Math.mulDiv(opt.strikePrice, (10**quoteDecimals), PRICE_PRECISION_FOR_STRIKE); // If strike was scaled
            // Or simply: collateralAmountToReturn = opt.strikePrice; if strikePrice is raw quote amount
        }
        
        // If the option was ActiveListed, it means it was escrowed in this contract.
        // The collateral is in the vault.
        if (opt.currentState == OptionState.ActiveListed) {
            // This NFT was never sold. The writer gets their collateral back.
            // And the NFT should be "returned" to writer or burned.
            // Since it's minted to address(this), we burn it.
             _burn(tokenId);
        }
        // If ActiveOwned and expired, NFT is with a holder. Collateral still with writer.

        collateralVault.releaseExpiredCollateral(opt.seriesKey, opt.writer, collateralToken, collateralAmountToReturn);
        opt.currentState = OptionState.ExpiredClaimedByWriter;

        emit OptionExpiredAndClaimed(tokenId, opt.writer, collateralToken, collateralAmountToReturn);
    }


    // --- Helper Functions ---
    function _calculateSeriesKey(
        address underlying, address quote, uint256 strike, uint64 expiry, bool isCall
    ) internal pure returns (bytes32) {
        return keccak256(abi.encodePacked(underlying, quote, strike, expiry, isCall));
    }

    function _getOracleAssetId(address asset, address quoteForContext, bool isCallForContext) internal view returns (uint256) {
        // For V1, assume asset address itself can be used as assetId for oracle,
        // or a mapping is maintained in OptionsAdmin or here if complex.
        // This needs to map to what OracleRelayerDst expects.
        // If sAssets are used, could query SynthFactory.
        // For now, simple hash or direct use, but this is a placeholder for robust ID resolution.
        return uint256(uint160(asset)); // Simplistic, assumes oracle uses this. NOT ROBUST.
                                        // Needs to map to asset IDs configured in OracleRelayerDst.
    }

    // --- Metadata (User-settable URI) ---
    function setMyOrderTokenURI(uint256 tokenId, string calldata uri) external {
        require(ERC721.ownerOf(tokenId) == _msgSender(), "OptionNFT: Not token owner");
        _setTokenURI(tokenId, uri);
        emit TokenURISet(tokenId, uri);
    }

    function tokenURI(uint256 tokenId)
        public view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        ERC721.ownerOf(tokenId); // Existence check
        string memory _uri = ERC721URIStorage.tokenURI(tokenId); // From OZ internal storage
        if (bytes(_uri).length > 0) {
            return _uri;
        }
        string memory baseURI = _fallbackBaseURI;
        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString(), ".json")) : "";
    }

    // --- OZ v5 Hooks ---
    function _increaseBalance(address account, uint128 value) internal override(ERC721, ERC721Enumerable) {
        super._increaseBalance(account, value);
    }
    function _update(address to, uint256 tokenId, address auth) internal override(ERC721, ERC721Enumerable) returns (address from) {
        return super._update(to, tokenId, auth);
    }
    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721Enumerable, ERC721URIStorage) returns (bool) {
        return super.supportsInterface(interfaceId);
    }

    /* ──────────────── Permit helpers (Robust implementations needed here) ──────────────── */
    // These would be similar to OrderNFT's, using PermitHelper for ERC2612 and Permit2
    // to wrap calls to `writeAndListOptions` or `buyListedOption`.
    // Example skeleton for one:
    function writeAndListOptionsWithPermitERC2612(
        // ERC2612 Permit parameters for collateralToken
        address tokenToPermit, address owner, uint256 permitValue, uint256 deadline,
        uint8 v, bytes32 r, bytes32 s,
        // writeAndListOptions parameters
        address underlying, address quote, uint256 strike, uint64 expiry, bool _isCall,
        uint256 quantity, uint256 premiumPerOption
    ) external returns (uint256[] memory tokenIds) {
        require(owner == _msgSender(), "OptionNFT: Permit owner mismatch");
        // Determine collateralToken based on _isCall
        address collateralToken = _isCall ? underlying : quote;
        require(tokenToPermit == collateralToken, "OptionNFT: Permit token mismatch with collateral");
        // Determine collateralAmount based on quantity and type
        // ... (logic similar to writeAndListOptions) ...
        // require(permitValue >= totalCollateralToLock, "OptionNFT: Permit value insufficient");

        // This callData should target an *internal* version of writeAndListOptions that
        // assumes approval and takes `originalMaker` as a parameter.
        // For now, this is complex to fully flesh out without that internal function.
        // The PermitHelper pattern assumes the target function (`writeAndListOptions`)
        // can be called after the permit gives allowance to `address(this)`.
        // `writeAndListOptions` calls `collateralVault.lockCollateral` which pulls from writer.
        // So, the spender in ERC2612 permit must be `address(collateralVault)`.

        bytes memory callData = abi.encodeWithSelector(
            this.writeAndListOptions.selector, // This won't work as _msgSender inside will be PermitHelper
            underlying, quote, strike, expiry, _isCall, quantity, premiumPerOption
            // Need an internal _writeAndListOptions(originalMaker, ...)
        );

        // Correct spender for ERC2612 permit: collateralVault
        permitHelper.erc2612PermitAndCall(
            IERC20Permit(tokenToPermit), owner, address(collateralVault), permitValue,
            deadline, v, r, s,
            address(this), // Target is this contract
            callData       // To call an internal function that takes originalMaker
        );
        // Result decoding to get tokenIds is needed.
        // This part requires significant refactoring of writeAndListOptions to have an internal,
        // authorized version, or a different permit flow.
        revert("Permit functions for options need further implementation details");
    }
}
### File: packages/contracts/options/CollateralVault.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol"; // Owned by OptionsAdmin
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/Pausable.sol";

/**
 * @title CollateralVault
 * @author Unxversal Team
 * @notice Securely holds and manages collateral for written options.
 * @dev Interacts with OptionNFT contract to lock collateral from writers and release it
 *      upon option exercise or expiry. Only authorized contracts (OptionNFT) can trigger
 *      core lock/release functions pertaining to user collateral.
 */
contract CollateralVault is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    // Address of the OptionNFT contract, authorized to instruct this vault.
    address public optionNFTContract;

    // Tracks locked collateral: seriesKey => writer => collateralToken => amount
    // seriesKey is keccak256(underlying, quote, strike, expiry, isCall)
    mapping(bytes32 => mapping(address => mapping(address => uint256))) public lockedCollateral;

    event CollateralLocked(
        bytes32 indexed seriesKey,
        address indexed writer,
        address indexed collateralToken,
        uint256 amountLocked
    );
    event CollateralReleasedForExercise(
        bytes32 indexed seriesKey,
        address indexed writer,
        address indexed holder,
        address payoutTokenToHolder,
        uint256 payoutAmountToHolder,
        address collateralTokenToWriter, // Token type returned to writer
        uint256 amountCollateralReturnedToWriter // Portion of original collateral returned
    );
    event ExpiredCollateralReleased(
        bytes32 indexed seriesKey,
        address indexed writer,
        address indexed collateralToken,
        uint256 amountReturned
    );
    event OptionNFTContractSet(address indexed newOptionNFTAddress);

    modifier onlyOptionNFT() {
        require(msg.sender == optionNFTContract, "CV: Caller not OptionNFT");
        _;
    }

    /**
     * @param _initialOwner The address of the OptionsAdmin contract.
     * @param _optionNFTContractAddress The initial address of the OptionNFT contract.
     */
    constructor(address _initialOwner, address _optionNFTContractAddress) Ownable(_initialOwner) {
        setOptionNFTContract(_optionNFTContractAddress); // Emits event
    }

    // --- Admin Functions (Callable by Owner - OptionsAdmin) ---
    function setOptionNFTContract(address _newOptionNFTAddress) public onlyOwner {
        require(_newOptionNFTAddress != address(0), "CV: Zero OptionNFT address");
        optionNFTContract = _newOptionNFTAddress;
        emit OptionNFTContractSet(_newOptionNFTAddress);
    }

    function pauseActions() external onlyOwner { // Pauses lock/release functions
        _pause();
    }

    function unpauseActions() external onlyOwner {
        _unpause();
    }

    // --- Core Functions (Callable by OptionNFT contract) ---

    /**
     * @notice Locks collateral from a writer for a new batch of written options.
     * @dev Called by OptionNFT. This vault pulls tokens from the writer.
     * @param seriesKey Identifier for the option series.
     * @param writer The address of the option writer.
     * @param collateralToken The ERC20 token being locked as collateral.
     * @param totalAmountToLock The total amount of collateralToken to lock.
     */
    function lockCollateral(
        bytes32 seriesKey,
        address writer,
        address collateralToken,
        uint256 totalAmountToLock
    ) external nonReentrant whenNotPaused onlyOptionNFT {
        require(writer != address(0), "CV: Zero writer address");
        require(collateralToken != address(0), "CV: Zero collateral token");
        require(totalAmountToLock > 0, "CV: Zero lock amount");

        lockedCollateral[seriesKey][writer][collateralToken] += totalAmountToLock;
        IERC20(collateralToken).safeTransferFrom(writer, address(this), totalAmountToLock);

        emit CollateralLocked(seriesKey, writer, collateralToken, totalAmountToLock);
    }

    /**
     * @notice Releases collateral and/or payout upon option exercise.
     * @dev Called by OptionNFT. Transfers assets from this vault.
     * @param seriesKey Identifier for the option series.
     * @param writer The original writer of the option.
     * @param holder The current holder exercising the option.
     * @param payoutTokenToHolder The token to be paid out to the holder.
     * @param payoutAmountToHolder The amount of payoutTokenToHolder to send to the holder.
     * @param strikePaymentTokenFromHolderForWriter For CALLS, this is quote asset. For PUTS, this is underlying.
     *                                               This token comes from holder to writer (via this vault).
     * @param strikePaymentAmountFromHolderForWriter Amount of strikePaymentToken.
     * @param collateralAssetOriginallyLocked The asset type originally locked by the writer for this option.
     * @param portionOfCollateralConsumedForPayout Amount of original collateral consumed for this exercise.
     */
    function releaseForExercise(
        bytes32 seriesKey,
        address writer,
        address holder,
        address payoutTokenToHolder,        // e.g., Underlying for Call, Quote for Put
        uint256 payoutAmountToHolder,
        address strikePaymentTokenFromHolderForWriter, // e.g., Quote for Call, Underlying for Put
        uint256 strikePaymentAmountFromHolderForWriter,
        address collateralAssetOriginallyLocked, // The token writer initially locked
        uint256 portionOfCollateralConsumedForPayout // In units of collateralAssetOriginallyLocked
    ) external nonReentrant whenNotPaused onlyOptionNFT {
        require(writer != address(0) && holder != address(0), "CV: Zero address");
        require(payoutTokenToHolder != address(0), "CV: Zero payout token");
        // payoutAmountToHolder can be 0 if OTM and still exercised (not typical, but possible if allowed by OptionNFT)

        // 1. Handle strike payment from holder (if any) -> to writer
        // OptionNFT should ensure this vault has received the strike payment from holder before calling this.
        // This function assumes strikePaymentAmountFromHolderForWriter is ALREADY in this vault, sent by OptionNFT.
        if (strikePaymentAmountFromHolderForWriter > 0) {
            require(strikePaymentTokenFromHolderForWriter != address(0), "CV: Zero strike payment token");
            IERC20(strikePaymentTokenFromHolderForWriter).safeTransfer(writer, strikePaymentAmountFromHolderForWriter);
        }

        // 2. Update writer's locked collateral record
        uint256 currentLocked = lockedCollateral[seriesKey][writer][collateralAssetOriginallyLocked];
        require(currentLocked >= portionOfCollateralConsumedForPayout, "CV: Insufficient locked collateral");
        lockedCollateral[seriesKey][writer][collateralAssetOriginallyLocked] = currentLocked - portionOfCollateralConsumedForPayout;

        // 3. Payout to holder (from the consumed collateral)
        if (payoutAmountToHolder > 0) {
            // This payoutTokenToHolder must be the same as collateralAssetOriginallyLocked for a simple model
            // OR this vault needs to manage diverse collateral pools.
            // For now, assume payoutTokenToHolder IS the collateralAssetOriginallyLocked for calls/puts.
            // e.g. Call: writer locks ETH, holder gets ETH. Put: writer locks USDC, holder gets USDC.
            require(payoutTokenToHolder == collateralAssetOriginallyLocked, "CV: Payout token mismatch with locked collateral asset");
            IERC20(payoutTokenToHolder).safeTransfer(holder, payoutAmountToHolder);
        }
        
        // What if portionOfCollateralConsumedForPayout > payoutAmountToHolder? (e.g. ITM Puts where strike > underlying value)
        // Example: ETH Put, Strike $3000. ETH price $2800. Holder gets $3000 USDC. Writer locked $3000 USDC.
        // Here, payoutTokenToHolder = USDC, payoutAmountToHolder = 3000.
        // collateralAssetOriginallyLocked = USDC, portionOfCollateralConsumed = 3000.
        // Example: ETH Call, Strike $3000. ETH price $3200. Holder gets 1 ETH. Writer locked 1 ETH.
        // Here, payoutTokenToHolder = ETH, payoutAmountToHolder = 1.
        // collateralAssetOriginallyLocked = ETH, portionOfCollateralConsumed = 1.

        emit CollateralReleasedForExercise(
            seriesKey, writer, holder,
            payoutTokenToHolder, payoutAmountToHolder,
            strikePaymentTokenFromHolderForWriter, strikePaymentAmountFromHolderForWriter // This is what writer received
        );
    }


    /**
     * @notice Releases collateral back to the writer for an expired and unexercised option.
     * @dev Called by OptionNFT.
     * @param seriesKey Identifier for the option series.
     * @param writer The address of the option writer.
     * @param collateralToken The ERC20 token that was locked.
     * @param amountToExpireAndReturn The amount of collateralToken to return.
     */
    function releaseExpiredCollateral(
        bytes32 seriesKey,
        address writer,
        address collateralToken,
        uint256 amountToExpireAndReturn
    ) external nonReentrant whenNotPaused onlyOptionNFT {
        require(writer != address(0), "CV: Zero writer");
        require(collateralToken != address(0), "CV: Zero collateral token");
        require(amountToExpireAndReturn > 0, "CV: Zero return amount");

        uint256 currentLocked = lockedCollateral[seriesKey][writer][collateralToken];
        require(currentLocked >= amountToExpireAndReturn, "CV: Exceeds locked collateral");
        lockedCollateral[seriesKey][writer][collateralToken] = currentLocked - amountToExpireAndReturn;

        IERC20(collateralToken).safeTransfer(writer, amountToExpireAndReturn);

        emit ExpiredCollateralReleased(seriesKey, writer, collateralToken, amountToExpireAndReturn);
    }

    // --- View Functions ---
    function getLockedCollateral(
        bytes32 seriesKey,
        address writer,
        address collateralToken
    ) external view returns (uint256) {
        return lockedCollateral[seriesKey][writer][collateralToken];
    }
}
### File: packages/contracts/options/OptionsAdmin.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../common/access/ProtocolAdminAccess.sol"; // Inherits Ownable
import "./OptionNFT.sol";
import "./CollateralVault.sol";
import "./OptionFeeSwitch.sol";
import "../common/interfaces/IOracleRelayer.sol";

/**
 * @title OptionsAdmin
 * @author Unxversal Team
 * @notice Administrative module for the Unxversal Options protocol.
 * @dev Manages parameters and target contract addresses for OptionNFT, CollateralVault,
 *      and OptionsFeeSwitch. Owned by a multisig or DAO Timelock.
 *      This contract will typically be the owner of the core options protocol contracts.
 */
contract OptionsAdmin is ProtocolAdminAccess {
    OptionNFT public optionNFT;
    CollateralVault public collateralVault;
    OptionsFeeSwitch public optionsFeeSwitch;
    IOracleRelayer public oracleRelayer; // Used by OptionNFT for exercise prices

    // Parameters that might be global to the options protocol
    uint256 public defaultMaxOptionFeeBps; // e.g., 100 BPS = 1% on premium/exercise

    event OptionNFTSet(address indexed nftAddress);
    event CollateralVaultSet(address indexed vaultAddress);
    event OptionsFeeSwitchSet(address indexed feeSwitchAddress);
    event OracleRelayerSet(address indexed oracleAddress);
    event DefaultMaxOptionFeeBpsSet(uint256 newMaxFeeBps);

    constructor(
        address _initialOwner,
        address _optionNFTAddress,
        address _collateralVaultAddress,
        address _optionsFeeSwitchAddress,
        address _oracleRelayerAddress
    ) ProtocolAdminAccess(_initialOwner) {
        setOptionNFT(_optionNFTAddress);
        setCollateralVault(_collateralVaultAddress);
        setOptionsFeeSwitch(_optionsFeeSwitchAddress);
        setOracleRelayer(_oracleRelayerAddress);
    }

    // --- Target Contract Setters ---
    function setOptionNFT(address _newNFTAddress) public onlyOwner {
        require(_newNFTAddress != address(0), "OptionsAdmin: Zero OptionNFT");
        optionNFT = OptionNFT(_newNFTAddress);
        emit OptionNFTSet(_newNFTAddress);
    }

    function setCollateralVault(address _newVaultAddress) public onlyOwner {
        require(_newVaultAddress != address(0), "OptionsAdmin: Zero CollateralVault");
        collateralVault = CollateralVault(_newVaultAddress);
        emit CollateralVaultSet(_newVaultAddress);
    }

    function setOptionsFeeSwitch(address _newFeeSwitchAddress) public onlyOwner {
        require(_newFeeSwitchAddress != address(0), "OptionsAdmin: Zero OptionsFeeSwitch");
        optionsFeeSwitch = OptionsFeeSwitch(_newFeeSwitchAddress);
        emit OptionsFeeSwitchSet(_newFeeSwitchAddress);
    }

    function setOracleRelayer(address _newOracleAddress) public onlyOwner {
        require(_newOracleAddress != address(0), "OptionsAdmin: Zero OracleRelayer");
        oracleRelayer = IOracleRelayer(_newOracleAddress);
        // Also set it on OptionNFT if it needs direct access (likely does for exercise)
        if (address(optionNFT) != address(0)) {
            // OptionNFT would need a `setOracle(address)` function callable by its owner (this admin contract)
            // optionNFT.setOracle(_newOracleAddress);
        }
        emit OracleRelayerSet(_newOracleAddress);
    }

    // --- Global Option Parameters ---
    function setDefaultMaxOptionFeeBps(uint256 _newMaxFeeBps) external onlyOwner {
        require(_newMaxFeeBps <= 1000, "OptionsAdmin: Fee too high (max 10%)"); // Example cap
        defaultMaxOptionFeeBps = _newMaxFeeBps;
        emit DefaultMaxOptionFeeBpsSet(_newMaxFeeBps);
    }

    // --- Whitelisting Assets (Optional, if not fully permissionless) ---
    // mapping(address => bool) public isUnderlyingSupported;
    // mapping(address => bool) public isQuoteSupported;
    // event AssetSupportChanged(address indexed asset, bool isSupported, bool isUnderlying);
    // function setAssetSupport(address asset, bool supported, bool isUnderlyingType) external onlyOwner { ... }

    // --- Protocol Pause ---
    // Assumes OptionNFT and CollateralVault implement Pausable and are owned by this admin.
    function pauseOptionsProtocol() external onlyOwner {
        if (address(optionNFT) != address(0) && !optionNFT.paused()) {
            // optionNFT.pause(); // OptionNFT needs pause()
        }
        if (address(collateralVault) != address(0) && !collateralVault.paused()) {
            // collateralVault.pause(); // CollateralVault needs pause()
        }
    }

    function unpauseOptionsProtocol() external onlyOwner {
        if (address(optionNFT) != address(0) && optionNFT.paused()) {
            // optionNFT.unpause();
        }
        if (address(collateralVault) != address(0) && collateralVault.paused()) {
            // collateralVault.unpause();
        }
    }

    // --- Ownership Transfers of Core Options Contracts ---
    function transferOptionNFTOwnership(address newOwner) external onlyOwner {
        require(address(optionNFT) != address(0), "OptionsAdmin: OptionNFT not set");
        optionNFT.transferOwnership(newOwner);
    }
    // ... similar for CollateralVault, OptionsFeeSwitch ...
}
### File: packages/contracts/lend/CorePool.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./interfaces/ICorePoolLens.sol";
import "./uToken.sol"; // Actual uToken contract for casting and interaction
import "./interestModels/IInterestRateModel.sol";
import "./LendRiskController.sol"; // For permission checks
// LendLiquidationEngine is not directly called by CorePool but CorePool is called by it.
import "../common/libraries/SafeDecimalMath.sol";


/**
 * @title CorePool
 * @author Unxversal Team
 * @notice Central contract for Unxversal Lend, managing markets, user balances, and interest.
 */
contract CorePool is Ownable, ReentrancyGuard, Pausable, ICorePoolLens {
    using SafeERC20 for IERC20;
    using SafeDecimalMath for uint256;
    using EnumerableSet for EnumerableSet.AddressSet;

    // --- Market State ---
    struct Market {
        bool isListed;
        address uTokenAddress;
        address interestRateModel;
        uint256 totalBorrowsPrincipal;  // Sum of all outstanding borrow principals (before interest)
        uint256 totalReserves;          // Total underlying reserves accumulated
        uint256 borrowIndex;            // Accumulator for borrow interest, scaled by BORROW_INDEX_PRECISION
        uint256 reserveFactorMantissa;  // Share of borrow interest for reserves (1e18 scaled)
        uint256 lastAccrualBlock;
        uint8 underlyingDecimals;       // Decimals of the underlying asset
    }
    mapping(address => Market) public markets; // underlyingAssetAddress => Market
    EnumerableSet.AddressSet private _listedMarketUnderlyings;

    // --- User State ---
    struct UserBorrowData {
        uint256 principal;      // User's current borrow principal for this asset
        uint256 interestIndex;  // Market's borrowIndex when user's principal was last updated
    }
    mapping(address => mapping(address => UserBorrowData)) public userBorrowData; // user => underlyingAsset => Data
    mapping(address => EnumerableSet.AddressSet) private _userSuppliedAssets;
    mapping(address => EnumerableSet.AddressSet) private _userBorrowedAssets;

    // --- Dependencies ---
    LendRiskController public riskController;
    address public liquidationEngineAddress; // Authorized to update balances and seize collateral

    // --- Constants ---
    uint256 public constant BORROW_INDEX_PRECISION = 1e18;

    // --- Events ---
    event MarketListed(address indexed underlying, address indexed uToken, address indexed irm);
    event MarketInterestAccrued(address indexed underlying, uint256 newBorrowIndex, uint256 newTotalBorrowsPrincipal, uint256 newTotalReserves);
    event Supply(address indexed user, address indexed underlying, uint256 amountUnderlying, uint256 amountUTokensMinted);
    event Withdraw(address indexed user, address indexed underlying, uint256 amountUnderlying, uint256 amountUTokensBurned);
    event Borrow(address indexed user, address indexed underlying, uint256 amountBorrowed);
    event RepayBorrow(address indexed payer, address indexed borrower, address indexed underlying, uint256 amountRepaid, uint256 newBorrowPrincipal);
    event ReserveFactorSet(address indexed underlying, uint256 newReserveFactorMantissa);
    event NewInterestRateModel(address indexed underlying, address indexed newIrm);
    event RiskControllerSet(address indexed newRiskController);
    event LiquidationEngineSet(address indexed newEngine);
    event ReservesWithdrawn(address indexed underlying, address indexed recipient, uint256 amountWithdrawn);
    event CollateralSeized(address indexed borrower, address indexed liquidator, address indexed collateralAsset, uint256 amountUnderlyingSeized);


    constructor(address _riskControllerAddress, address _initialOwner) Ownable(_initialOwner) {
        setRiskController(_riskControllerAddress); // Emits event
    }

    // --- Admin Functions ---
    function setRiskController(address _newRiskControllerAddress) public onlyOwner {
        require(_newRiskControllerAddress != address(0), "CorePool: Zero RiskController");
        riskController = LendRiskController(_newRiskControllerAddress);
        emit RiskControllerSet(_newRiskControllerAddress);
    }

    function setLiquidationEngine(address _newEngineAddress) public onlyOwner {
        require(_newEngineAddress != address(0), "CorePool: Zero LiquidationEngine");
        liquidationEngineAddress = _newEngineAddress;
        emit LiquidationEngineSet(_newEngineAddress);
    }

    function listMarket(address underlyingAsset, address _uTokenAddress, address _irmAddress) external onlyOwner {
        require(underlyingAsset != address(0) && _uTokenAddress != address(0) && _irmAddress != address(0), "CorePool: Zero address");
        Market storage market = markets[underlyingAsset];
        require(!market.isListed, "CorePool: Market already listed"); // For updates, use specific setters

        // Validate uToken and IRM (basic checks)
        require(uToken(_uTokenAddress).underlying() == underlyingAsset, "CorePool: uToken mismatch");
        // IInterestRateModel(_irmAddress).getBorrowRate(0,0,0); // Test call, can be gas intensive or revert

        market.isListed = true;
        market.uTokenAddress = _uTokenAddress;
        market.interestRateModel = _irmAddress;
        market.borrowIndex = BORROW_INDEX_PRECISION;
        market.lastAccrualBlock = block.number;
        market.underlyingDecimals = IERC20(underlyingAsset).decimals();
        _listedMarketUnderlyings.add(underlyingAsset);

        emit MarketListed(underlyingAsset, _uTokenAddress, _irmAddress);
    }

    function setReserveFactor(address underlyingAsset, uint256 newReserveFactorMantissa) external onlyOwner {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed");
        require(newReserveFactorMantissa <= BORROW_INDEX_PRECISION, "CorePool: Reserve factor too high");
        // Accrue interest before changing a parameter that affects its calculation
        accrueInterest(underlyingAsset);
        market.reserveFactorMantissa = newReserveFactorMantissa;
        emit ReserveFactorSet(underlyingAsset, newReserveFactorMantissa);
    }
    
    function setInterestRateModel(address underlyingAsset, address newIrmAddress) external onlyOwner {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed");
        require(newIrmAddress != address(0), "CorePool: Zero IRM");
        // Accrue interest with old model before switching
        accrueInterest(underlyingAsset);
        market.interestRateModel = newIrmAddress;
        emit NewInterestRateModel(underlyingAsset, newIrmAddress);
    }

    function withdrawReserves(address underlyingAsset, uint256 amountToWithdraw, address recipient) external onlyOwner nonReentrant {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed");
        require(recipient != address(0) && amountToWithdraw > 0, "CorePool: Invalid params");
        accrueInterest(underlyingAsset);
        require(market.totalReserves >= amountToWithdraw, "CorePool: Insufficient reserves");
        
        market.totalReserves -= amountToWithdraw;
        uToken(market.uTokenAddress).transferUnderlyingTo(recipient, amountToWithdraw);
        emit ReservesWithdrawn(underlyingAsset, recipient, amountToWithdraw);
    }

    function pause() public override onlyOwner { _pause(); } // OZ Pausable
    function unpause() public override onlyOwner { _unpause(); }


    // --- Interest Accrual ---
    function accrueInterest(address underlyingAsset) public override returns (uint256 newBorrowIndex) {
        Market storage market = markets[underlyingAsset];
        if (!market.isListed || market.lastAccrualBlock == block.number) {
            return market.borrowIndex;
        }

        uint256 currentTotalBorrowsPrincipal = market.totalBorrowsPrincipal;
        uint256 currentBorrowIndex = market.borrowIndex;
        uint256 currentTotalReserves = market.totalReserves;
        uint256 blockDelta = block.number - market.lastAccrualBlock;

        newBorrowIndex = currentBorrowIndex; // Default if no borrows

        if (currentTotalBorrowsPrincipal > 0 && blockDelta > 0) {
            IInterestRateModel irm = IInterestRateModel(market.interestRateModel);
            // Cash in uToken is its balance of underlying
            uint256 cashInUToken = IERC20(underlyingAsset).balanceOf(market.uTokenAddress);
            
            // Total current borrows with interest = principal * currentIndex / snapshotIndex (but we need rate)
            // The IRM takes current total borrows (with interest up to previous block)
            // For IRM, `totalBorrows` should be the current outstanding balance before new interest.
            uint256 totalBorrowsWithPrevInterest = currentTotalBorrowsPrincipal; // For IRM input, effectively

            uint256 borrowRatePerBlock = irm.getBorrowRate(
                cashInUToken, totalBorrowsWithPrevInterest, currentTotalReserves
            );

            // simpleInterestFactor = borrowRatePerBlock * blockDelta (both 1e18 scaled)
            uint256 simpleInterestFactor = borrowRatePerBlock.multiplyDecimal(blockDelta);
            uint256 interestAccumulated = totalBorrowsWithPrevInterest.multiplyDecimal(simpleInterestFactor);
            
            newBorrowIndex = currentBorrowIndex.multiplyDecimal(BORROW_INDEX_PRECISION + simpleInterestFactor);
            uint256 reservesAdded = interestAccumulated.multiplyDecimal(market.reserveFactorMantissa);
            
            market.totalBorrowsPrincipal = totalBorrowsWithPrevInterest + interestAccumulated - reservesAdded; // Principal grows by net interest
            market.totalReserves = currentTotalReserves + reservesAdded;
            market.borrowIndex = newBorrowIndex;
        }

        market.lastAccrualBlock = block.number;
        emit MarketInterestAccrued(underlyingAsset, newBorrowIndex, market.totalBorrowsPrincipal, market.totalReserves);
        return newBorrowIndex;
    }


    // --- User Operations ---
    function supply(address underlyingAsset, uint256 amount) external nonReentrant whenNotPaused {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed");
        require(amount > 0, "CorePool: Zero supply");
        accrueInterest(underlyingAsset);

        uToken uTokenContract = uToken(payable(market.uTokenAddress)); // payable for OZv5 uToken constructor casting
        uint256 exchangeRate = uTokenContract.exchangeRateStored();
        require(exchangeRate > 0, "CorePool: Invalid exchange rate");

        // User (msg.sender) approves CorePool. CorePool pulls, then transfers to uToken.
        IERC20(underlyingAsset).safeTransferFrom(_msgSender(), address(uTokenContract), amount);

        uint256 uTokensToMint = Math.mulDiv(amount, BORROW_INDEX_PRECISION, exchangeRate); // (amount * 1e18) / exRate
        uTokenContract.mintTokens(_msgSender(), uTokensToMint);
        
        _userSuppliedAssets[_msgSender()].add(underlyingAsset);
        emit Supply(_msgSender(), underlyingAsset, amount, uTokensToMint);
    }

    function withdraw(address underlyingAsset, uint256 uTokensToRedeem) external nonReentrant whenNotPaused {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed");
        require(uTokensToRedeem > 0, "CorePool: Zero redeem");
        accrueInterest(underlyingAsset);

        uToken uTokenContract = uToken(payable(market.uTokenAddress));
        uint256 exchangeRate = uTokenContract.exchangeRateStored();
        require(exchangeRate > 0, "CorePool: Invalid exchange rate");
        uint256 underlyingToWithdraw = Math.mulDiv(uTokensToRedeem, exchangeRate, BORROW_INDEX_PRECISION);

        require(address(riskController) != address(0), "CorePool: RiskController not set");
        riskController.preWithdrawCheck(_msgSender(), underlyingAsset, underlyingToWithdraw);

        // User must have uTokensToRedeem. uToken.burnTokens will check this.
        uTokenContract.burnTokens(_msgSender(), uTokensToRedeem);
        uTokenContract.transferUnderlyingTo(_msgSender(), underlyingToWithdraw);

        if (uTokenContract.balanceOf(_msgSender()) == 0) {
            _userSuppliedAssets[_msgSender()].remove(underlyingAsset);
        }
        emit Withdraw(_msgSender(), underlyingAsset, underlyingToWithdraw, uTokensToRedeem);
    }

    function borrow(address underlyingAsset, uint256 amountToBorrow) external nonReentrant whenNotPaused {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed");
        require(amountToBorrow > 0, "CorePool: Zero borrow");
        uint256 currentMarketBorrowIndex = accrueInterest(underlyingAsset);

        require(address(riskController) != address(0), "CorePool: RiskController not set");
        riskController.preBorrowCheck(_msgSender(), underlyingAsset, amountToBorrow);

        uToken uTokenContract = uToken(payable(market.uTokenAddress));
        uint256 cashInUToken = IERC20(underlyingAsset).balanceOf(market.uTokenAddress);
        require(cashInUToken >= amountToBorrow, "CorePool: Insufficient market liquidity");

        UserBorrowData storage borrowData = userBorrowData[_msgSender()][underlyingAsset];
        uint256 accountBorrowsPrior = _getAccountBorrowBalanceSnapshot(borrowData, currentMarketBorrowIndex);
        uint256 newBorrowPrincipalSnapshot = accountBorrowsPrior + amountToBorrow;
        
        borrowData.principal = newBorrowPrincipalSnapshot;
        borrowData.interestIndex = currentMarketBorrowIndex;
        market.totalBorrowsPrincipal += amountToBorrow; // Add to market's principal debt

        uTokenContract.transferUnderlyingTo(_msgSender(), amountToBorrow);
        _userBorrowedAssets[_msgSender()].add(underlyingAsset);
        emit Borrow(_msgSender(), underlyingAsset, amountToBorrow);
    }

    function repayBorrow(address underlyingAsset, uint256 amountToRepay) external nonReentrant whenNotPaused {
        _repayBorrowInternal(_msgSender(), _msgSender(), underlyingAsset, amountToRepay);
    }

    function repayBorrowBehalf(address borrower, address underlyingAsset, uint256 amountToRepay) external nonReentrant whenNotPaused {
        _repayBorrowInternal(_msgSender(), borrower, underlyingAsset, amountToRepay);
    }

    function _repayBorrowInternal(address payer, address borrower, address underlyingAsset, uint256 amountToRepayInput) internal {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed");
        require(amountToRepayInput > 0, "CorePool: Zero repay");
        uint256 currentMarketBorrowIndex = accrueInterest(underlyingAsset);

        UserBorrowData storage borrowData = userBorrowData[borrower][underlyingAsset];
        uint256 accountBorrowsPrior = _getAccountBorrowBalanceSnapshot(borrowData, currentMarketBorrowIndex);
        require(accountBorrowsPrior > 0, "CorePool: No outstanding borrow");

        uint256 actualRepayAmount;
        if (amountToRepayInput == type(uint256).max || amountToRepayInput >= accountBorrowsPrior) {
            actualRepayAmount = accountBorrowsPrior;
            borrowData.principal = 0;
            borrowData.interestIndex = 0; // Cleared
            _userBorrowedAssets[borrower].remove(underlyingAsset);
        } else {
            actualRepayAmount = amountToRepayInput;
            borrowData.principal = accountBorrowsPrior - actualRepayAmount;
            borrowData.interestIndex = currentMarketBorrowIndex;
        }

        market.totalBorrowsPrincipal -= actualRepayAmount; // Reduce market's principal debt
        uToken uTokenContract = uToken(payable(market.uTokenAddress));
        IERC20(underlyingAsset).safeTransferFrom(payer, address(uTokenContract), actualRepayAmount);

        emit RepayBorrow(payer, borrower, underlyingAsset, actualRepayAmount, borrowData.principal);
    }

    /** @dev Gets snapshot of borrow balance based on stored principal and market index. */
    function _getAccountBorrowBalanceSnapshot(UserBorrowData storage borrowData, uint256 marketBorrowIndex)
        internal view returns (uint256)
    {
        if (borrowData.principal == 0) return 0;
        return Math.mulDiv(borrowData.principal, marketBorrowIndex, borrowData.interestIndex);
    }

    // --- Liquidation Hooks ---
    modifier onlyLiquidationEngine() {
        require(_msgSender() == liquidationEngineAddress, "CorePool: Caller not LiquidationEngine");
        _;
    }

    function reduceBorrowBalanceForLiquidation(
        address borrower, address underlyingAsset, uint256 amountRepaidByLiquidator
    ) external nonReentrant onlyLiquidationEngine {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed for liq reduce");
        uint256 currentMarketBorrowIndex = accrueInterest(underlyingAsset);

        UserBorrowData storage borrowData = userBorrowData[borrower][underlyingAsset];
        uint256 accountBorrowsPrior = _getAccountBorrowBalanceSnapshot(borrowData, currentMarketBorrowIndex);
        require(accountBorrowsPrior >= amountRepaidByLiquidator, "CorePool: Liq repay > borrow bal");

        uint256 accountBorrowsNewPrincipal = accountBorrowsPrior - amountRepaidByLiquidator;
        borrowData.principal = accountBorrowsNewPrincipal;
        borrowData.interestIndex = currentMarketBorrowIndex;
        if (accountBorrowsNewPrincipal == 0) {
             _userBorrowedAssets[borrower].remove(underlyingAsset);
        }
        market.totalBorrowsPrincipal -= amountRepaidByLiquidator;
        // Note: The actual underlying tokens for this repayment are handled by LendLiquidationEngine
        // by transferring them to the debtAsset's uToken.
        emit RepayBorrow(liquidationEngineAddress, borrower, underlyingAsset, amountRepaidByLiquidator, accountBorrowsNewPrincipal);
    }

    /**
     * @notice Called by the LiquidationEngine to facilitate a debt repayment by a liquidator on behalf of a borrower.
     * @dev The liquidator must have approved CorePool to spend `amountToRepay` of `underlyingAsset`.
     *      This function is essentially a specialized version of `repayBorrowBehalf` for liquidations.
     * @param liquidator The address of the liquidator who is providing the funds for repayment.
     * @param borrower The address of the user whose borrow is being repaid.
     * @param underlyingAsset The address of the underlying asset being repaid.
     * @param amountToRepay The amount of underlying asset to repay.
     */
    function repayBorrowBehalfByEngine(
        address liquidator,
        address borrower,
        address underlyingAsset,
        uint256 amountToRepay
    ) external nonReentrant onlyLiquidationEngine { // Note: no whenNotPaused, liquidation should work even if user actions are paused
        // Call the existing internal repay logic, but with `liquidator` as the payer
        _repayBorrowInternal(liquidator, borrower, underlyingAsset, amountToRepay);
    }

    function seizeAndTransferCollateral(
        address borrower, address liquidator,
        address underlyingCollateralAsset, uint256 amountUnderlyingToSeize
    ) external nonReentrant onlyLiquidationEngine {
        Market storage market = markets[underlyingCollateralAsset];
        require(market.isListed, "CorePool: Collateral market not listed for seize");
        require(amountUnderlyingToSeize > 0, "CorePool: Zero seize amount");
        accrueInterest(underlyingCollateralAsset);

        uToken uTokenCollateral = uToken(payable(market.uTokenAddress));
        uint256 exchangeRate = uTokenCollateral.exchangeRateStored();
        require(exchangeRate > 0, "CorePool: Invalid collateral exchange rate");

        // Calculate uTokens corresponding to the amount of underlying to seize
        uint256 uTokensToSeize = Math.mulDiv(amountUnderlyingToSeize, BORROW_INDEX_PRECISION, exchangeRate);
        require(uTokenCollateral.balanceOf(borrower) >= uTokensToSeize, "CorePool: Borrower insufficient uTokens to seize");

        // Burn borrower's uTokens representing the seized collateral portion
        uTokenCollateral.burnTokens(borrower, uTokensToSeize);
        // Transfer the underlying collateral from uToken contract to the liquidator
        uTokenCollateral.transferUnderlyingTo(liquidator, amountUnderlyingToSeize);

        if (uTokenCollateral.balanceOf(borrower) == 0) {
            _userSuppliedAssets[borrower].remove(underlyingCollateralAsset);
        }
        emit CollateralSeized(borrower, liquidator, underlyingCollateralAsset, amountUnderlyingToSeize);
    }

    // --- ICorePoolLens Implementation ---
    function getUserSupplyAndBorrowBalance(address user, address underlyingAsset)
        external view override
        returns (uint256 uTokenSupplyBalance, uint256 underlyingBorrowBalanceWithInterest)
    {
        Market storage market = markets[underlyingAsset];
        if (!market.isListed) return (0, 0);
        uTokenSupplyBalance = uToken(market.uTokenAddress).balanceOf(user);
        
        uint256 marketIdx = _getViewMarketBorrowIndex(underlyingAsset);
        underlyingBorrowBalanceWithInterest = _getAccountBorrowBalanceSnapshot(userBorrowData[user][underlyingAsset], marketIdx);
    }

    function getAssetsUserSupplied(address user) external view override returns (address[] memory) {
        return _userSuppliedAssets[user].values();
    }

    function getAssetsUserBorrowed(address user) external view override returns (address[] memory) {
        return _userBorrowedAssets[user].values();
    }

    function getUTokenForUnderlying(address underlyingAsset) external view override returns (address) {
        return markets[underlyingAsset].uTokenAddress;
    }

    function getInterestRateModelForUnderlying(address underlyingAsset) external view override returns (address) {
        return markets[underlyingAsset].interestRateModel;
    }

    // --- Public View Functions for Market State ---
    function _getViewMarketBorrowIndex(address underlyingAsset) internal view returns (uint256) {
        Market storage market = markets[underlyingAsset];
        if (!market.isListed || market.lastAccrualBlock == block.number || market.totalBorrowsPrincipal == 0) {
            return market.borrowIndex;
        }
        uint256 blockDelta = block.number - market.lastAccrualBlock;
        IInterestRateModel irm = IInterestRateModel(market.interestRateModel);
        uint256 cash = IERC20(underlyingAsset).balanceOf(market.uTokenAddress);
        uint256 simpleInterestFactor = irm.getBorrowRate(
            cash, market.totalBorrowsPrincipal, market.totalReserves
        ).multiplyDecimal(blockDelta);
        return market.borrowIndex.multiplyDecimal(BORROW_INDEX_PRECISION + simpleInterestFactor);
    }

    function totalBorrowsCurrent(address underlyingAsset) external view returns (uint256) {
        Market storage market = markets[underlyingAsset];
        if (!market.isListed || market.totalBorrowsPrincipal == 0) return 0;
        uint256 marketIdx = _getViewMarketBorrowIndex(underlyingAsset);
        // This is not quite right. totalBorrowsPrincipal needs to be scaled by marketIdx / some_initial_index (which is 1e18)
        // Total borrows principal already includes accrued interest conceptually.
        // The `market.totalBorrowsPrincipal` after accrual *is* the current total borrows.
        // So, for a view, we need to simulate the accrual's effect on `totalBorrowsPrincipal`.
        
        if (market.lastAccrualBlock == block.number) return market.totalBorrowsPrincipal;
        
        uint256 blockDelta = block.number - market.lastAccrualBlock;
        IInterestRateModel irm = IInterestRateModel(market.interestRateModel);
        uint256 cash = IERC20(underlyingAsset).balanceOf(market.uTokenAddress);
        uint256 borrowRate = irm.getBorrowRate(cash, market.totalBorrowsPrincipal, market.totalReserves);
        uint256 interestAccumulated = market.totalBorrowsPrincipal.multiplyDecimal(borrowRate.multiplyDecimal(blockDelta));
        return market.totalBorrowsPrincipal + interestAccumulated - interestAccumulated.multiplyDecimal(market.reserveFactorMantissa);
    }

    function totalReserves(address underlyingAsset) external view override returns (uint256) {
        Market storage market = markets[underlyingAsset];
         if (!market.isListed || market.lastAccrualBlock == block.number || market.totalBorrowsPrincipal == 0) {
            return market.totalReserves;
        }
        uint256 blockDelta = block.number - market.lastAccrualBlock;
        IInterestRateModel irm = IInterestRateModel(market.interestRateModel);
        uint256 cash = IERC20(underlyingAsset).balanceOf(market.uTokenAddress);
        uint256 borrowRate = irm.getBorrowRate(cash, market.totalBorrowsPrincipal, market.totalReserves);
        uint256 interestAccumulated = market.totalBorrowsPrincipal.multiplyDecimal(borrowRate.multiplyDecimal(blockDelta));
        uint256 reservesAdded = interestAccumulated.multiplyDecimal(market.reserveFactorMantissa);
        return market.totalReserves + reservesAdded;
    }

    function getMarketBorrowIndex(address underlyingAsset) external view returns (uint256) {
        return _getViewMarketBorrowIndex(underlyingAsset);
    }

     function getMarketState(address underlyingAsset) external view returns (
        uint256 _totalBorrows, uint256 _totalReserves, uint256 _borrowIndex,
        uint256 _lastAccrualBlock, uint256 _reserveFactorMantissa, uint8 _underlyingDecimals
    ) {
        Market storage market = markets[underlyingAsset];
        require(market.isListed, "CorePool: Market not listed");
        // For view, simulate accrual to show current values
        _totalBorrows = totalBorrowsCurrent(underlyingAsset);
        _totalReserves = totalReserves(underlyingAsset);
        _borrowIndex = _getViewMarketBorrowIndex(underlyingAsset);
        _lastAccrualBlock = market.lastAccrualBlock; // Stored last accrual
        _reserveFactorMantissa = market.reserveFactorMantissa;
        _underlyingDecimals = market.underlyingDecimals;
    }
}
### File: packages/contracts/lend/uToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"; // For burning uTokens
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol"; // uToken itself is Ownable by CorePool or LendAdmin for init
import "@openzeppelin/contracts/utils/math/Math.sol";
import "../common/libraries/SafeDecimalMath.sol"; // For exchange rate math

// Forward declaration or interface for CorePool to avoid circular deps if CorePool imports uToken interface
interface ICorePool {
    function accrueInterest(address uTokenAddress) external returns (uint256 newBorrowIndex);
    function totalBorrowsCurrent(address uTokenAddress) external view returns (uint256);
    function totalReserves(address uTokenAddress) external view returns (uint256);
    // Potentially other functions CorePool exposes that uToken might need, though uToken is usually passive.
}

/**
 * @title uToken
 * @author Unxversal Team
 * @notice Interest-bearing token representing a user's supply in a lending pool.
 * @dev ERC20 token that holds the underlying asset. Exchange rate against underlying
 *      increases as interest accrues in the CorePool for this market.
 *      Minting/burning controlled by CorePool.
 */
contract uToken is ERC20, ERC20Burnable, Ownable {
    using SafeDecimalMath for uint256;
    using SafeERC20 for IERC20;

    IERC20 public immutable underlying; // The underlying asset (e.g., USDC, WETH)
    ICorePool public corePool;       // The CorePool contract managing this uToken market

    // Precision for exchange rate calculations (1e18)
    uint256 internal constant EXCHANGE_RATE_PRECISION = 1e18;

    // Initial exchange rate is 1 uToken = 1 underlying unit (scaled by precision and decimals)
    // More accurately, the initial exchange rate is often fixed, e.g., 0.02 * 1e18 if 1 uToken = 0.02 underlying.
    // For simplicity, let's start with an initial rate that implies 1:1 value scaling,
    // considering underlying decimals.
    // For example, if underlying has 6 decimals, and uToken has 18,
    // initial rate might be 1 * 10^(18-6) * 1e18.
    // A common starting point for uTokens is an initialExchangeRateMantissa.
    // Let's set initial exchange rate to effectively be 1 underlying = 1 uToken in value terms, adjusted for decimals.
    // The actual stored exchange rate will be scaled by 1e18.
    // exchangeRate = (total cash + total borrows - total reserves) / totalSupply of uTokens
    // For V1, let's simplify and assume uToken decimals are always 18.
    // Initial exchange rate can be set such that 1 uToken represents a certain value of underlying.
    // For now, the exchange rate is derived dynamically.

    // Event for exchange rate updates (though it changes implicitly with interest accrual)
    // event ExchangeRateUpdated(uint256 newExchangeRateMantissa);


    /**
     * @param _underlyingAsset Address of the underlying ERC20 token.
     * @param _corePoolAddress Address of the CorePool contract.
     * @param name_ Name of this uToken (e.g., "Unxversal USDC").
     * @param symbol_ Symbol of this uToken (e.g., "uUSDC").
     * @param _admin The address that will be the owner of this uToken contract
     *               (typically the CorePool or LendAdmin for setup).
     */
    constructor(
        address _underlyingAsset,
        address _corePoolAddress,
        string memory name_,
        string memory symbol_,
        address _admin
    ) ERC20(name_, symbol_) Ownable(_admin) {
        require(_underlyingAsset != address(0), "uToken: Zero underlying");
        require(_corePoolAddress != address(0), "uToken: Zero CorePool");
        underlying = IERC20(_underlyingAsset);
        corePool = ICorePool(_corePoolAddress);
    }

    // --- Core Logic controlled by CorePool ---

    /**
     * @notice Mints uTokens to a user. Only callable by CorePool.
     * @param minter The address to mint uTokens to.
     * @param mintAmount The amount of uTokens to mint.
     */
    function mintTokens(address minter, uint256 mintAmount) external {
        require(msg.sender == address(corePool), "uToken: Caller not CorePool");
        _mint(minter, mintAmount);
    }

    /**
     * @notice Burns uTokens from a user. Only callable by CorePool.
     * @dev This function calls the internal _burn. CorePool will have ensured the user
     *      has sufficient uTokens and that the burn is valid.
     *      This is different from ERC20Burnable.burn(amount) which burns msg.sender's tokens.
     * @param burner The address to burn uTokens from.
     * @param burnAmount The amount of uTokens to burn.
     */
    function burnTokens(address burner, uint256 burnAmount) external {
        require(msg.sender == address(corePool), "uToken: Caller not CorePool");
        _burn(burner, burnAmount); // Burns `burner`'s tokens
    }

    /**
     * @notice Transfers underlying tokens from this uToken contract to a recipient.
     * @dev Only callable by CorePool, typically during withdrawals or borrows.
     * @param recipient The address to receive the underlying tokens.
     * @param amount The amount of underlying tokens to transfer.
     */
    function transferUnderlyingTo(address recipient, uint256 amount) external returns (bool) {
        require(msg.sender == address(corePool), "uToken: Caller not CorePool");
        SafeERC20.safeTransfer(underlying, recipient, amount);
        return true;
    }

    /**
     * @notice Fetches underlying tokens into this uToken contract from a sender.
     * @dev Only callable by CorePool, typically during supplies or repayments.
     *      Sender must have approved CorePool (or this uToken via CorePool) for the amount.
     * @param sender The address to pull underlying tokens from.
     * @param amount The amount of underlying tokens to fetch.
     */
    function fetchUnderlyingFrom(address sender, uint256 amount) external returns (bool) {
        require(msg.sender == address(corePool), "uToken: Caller not CorePool");
        // CorePool should ensure that `sender` has approved `address(corePool)`
        // and CorePool then calls `underlying.transferFrom(sender, address(this_uToken), amount)`
        // OR, sender approves this uToken contract directly, and CorePool triggers this.
        // The first pattern is more common (approve controller, controller pulls).
        // This uToken function assumes the allowance is set up for CorePool to manage.
        // If CorePool is msg.sender, it can instruct this uToken to pull from `sender` if `sender` approved `CorePool`.
        // This requires `underlying.transferFrom(sender, address(this), amount)` but needs CorePool's context.

        // Simpler: CorePool pulls tokens from user to ITSELF, then transfers to this uToken.
        // Or, User approves this uToken contract, CorePool calls this.
        // Let's assume user approves this uToken contract.
        SafeERC20.safeTransferFrom(underlying, sender, address(this), amount);
        return true;
    }

    // --- Exchange Rate Logic ---

    /**
     * @notice Calculates the current exchange rate of uTokens to underlying tokens.
     * @dev exchangeRate = (totalUnderlyingBalance + totalBorrows - totalReserves) / totalUTokenSupply
     *      All scaled by EXCHANGE_RATE_PRECISION.
     *      Returns 0 if total uToken supply is 0.
     * @return The exchange rate, scaled by 1e18.
     */
    function exchangeRateCurrent() public returns (uint256) {
        // Accrue interest first to get the latest totalBorrows and totalReserves
        corePool.accrueInterest(address(this)); // Modifies state, so not view.
                                                // This is a common pattern for on-demand accrual.

        return exchangeRateStored(); // Now read the stored/calculated rate post-accrual
    }

    /**
     * @notice Returns the stored exchange rate. Call `exchangeRateCurrent()` to accrue interest first.
     * @dev This value is only updated when `accrueInterest` is called on the CorePool for this market.
     * @return The stored exchange rate, scaled by 1e18.
     */
    function exchangeRateStored() public view returns (uint256) {
        uint256 _totalSupply = totalSupply();
        if (_totalSupply == 0) {
            // Typically, there's an initial exchange rate if supply is 0.
            // For Compound, it's initialExchangeRateMantissa (e.g., 0.02 * 1e18).
            // Let's assume a scenario where if no supply, rate is effectively based on 1 unit for simplicity,
            // or return a defined initial exchange rate.
            // For now, if no uTokens, it implies no underlying value managed by it in this context.
            // A common initial rate if _totalSupply is 0 could be 1 underlying unit scaled.
            // Let's define an initial exchange rate or handle this carefully.
            // For now, returning 0 if no supply is problematic.
            // The first minter will establish the initial rate effectively.
            // Let's use a fixed initial exchange rate if totalSupply is 0.
            // e.g., 1 uToken = 1 underlying unit, scaled.
            // This requires knowing underlying decimals.
            // For simplicity, let's assume uTokens and underlying have same "value" basis initially.
            // A common start is 1 uToken = X underlying, and X is fixed. Let's use 1e18 as default.
            return EXCHANGE_RATE_PRECISION; // Placeholder for a proper initial exchange rate
        }

        uint256 cash = underlying.balanceOf(address(this));
        uint256 borrows = corePool.totalBorrowsCurrent(address(this)); // Current total borrows for this uToken's market
        uint256 reserves = corePool.totalReserves(address(this)); // Current reserves for this market

        uint256 totalAssetValue = cash + borrows;
        if (totalAssetValue < reserves) { // Should not happen if reserves are derived from interest
            totalAssetValue = 0;
        } else {
            totalAssetValue -= reserves;
        }
        
        // exchangeRate = (cash + borrows - reserves) * 1e18 / totalSupply
        // (cash + borrows - reserves) is the total underlying asset value backing the uTokens
        // Using Math.mulDiv for clarity: (totalAssetValue * EXCHANGE_RATE_PRECISION) / _totalSupply
        return Math.mulDiv(totalAssetValue, EXCHANGE_RATE_PRECISION, _totalSupply);
    }

    /**
     * @notice Accrues interest for this uToken market by calling CorePool.
     * @dev This is a wrapper and also a state-changing operation.
     */
    function accrueMarketInterest() external {
        corePool.accrueInterest(address(this));
    }


    // --- ERC20Burnable Override ---
    // `burn(uint256 amount)` burns msg.sender's tokens.
    // `burnFrom(address account, uint256 amount)` burns from account if msg.sender has allowance.
    // These are standard and don't need overriding unless specific uToken logic required.
    // CorePool will call `burnTokens` which uses internal `_burn`.

    // --- Ownable functions (e.g., to change corePool address by admin) ---
    function setCorePool(address _newCorePoolAddress) external onlyOwner {
        require(_newCorePoolAddress != address(0), "uToken: Zero CorePool");
        corePool = ICorePool(_newCorePoolAddress);
    }
}
### File: packages/contracts/lend/interestModels/IInterestRateModel.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title IInterestRateModel
 * @author Unxversal Team
 * @notice Interface for interest rate models.
 * @dev Defines how borrow and supply rates are calculated for a given market.
 */
interface IInterestRateModel {
    /**
     * @notice Calculates the current borrow interest rate per block.
     * @param underlyingBalance The amount of underlying tokens currently in the uToken contract.
     * @param totalBorrows The total amount of underlying tokens currently borrowed from this market.
     * @param totalReserves The total amount of reserves accumulated for this market (if applicable to rate).
     * @return The borrow interest rate per block (e.g., scaled by 1e18 for a rate like 0.000001% per block).
     */
    function getBorrowRate(
        uint256 underlyingBalance,
        uint256 totalBorrows,
        uint256 totalReserves
    ) external view returns (uint256);

    /**
     * @notice Calculates the current supply interest rate per block.
     * @dev Supply Rate = Borrow Rate * Utilization Rate * (1 - Reserve Factor)
     * @param underlyingBalance The amount of underlying tokens currently in the uToken contract.
     * @param totalBorrows The total amount of underlying tokens currently borrowed.
     * @param totalReserves The total amount of reserves accumulated.
     * @param reserveFactorMantissa The reserve factor for the market (e.g., 0.1 * 1e18 for 10%).
     * @return The supply interest rate per block (e.g., scaled by 1e18).
     */
    function getSupplyRate(
        uint256 underlyingBalance,
        uint256 totalBorrows,
        uint256 totalReserves,
        uint256 reserveFactorMantissa
    ) external view returns (uint256);

    // Some models might expose their parameters
    // function getModelParameters() external view returns (bytes memory);
}
### File: packages/contracts/lend/interestModels/PiecewiseLinearInterestRateModel.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol"; // If params are updatable
import "@openzeppelin/contracts/utils/math/Math.sol";
import "./IInterestRateModel.sol";
import "../../common/libraries/SafeDecimalMath.sol"; // For precise calculations

/**
 * @title PiecewiseLinearInterestRateModel
 * @author Unxversal Team (Inspired by Compound/Aave V2 models)
 * @notice A standard interest rate model with a kink point.
 *         Borrow rates increase linearly based on utilization, with a steeper slope after the kink.
 * @dev All rates are per block. Precision is 1e18.
 */
contract PiecewiseLinearInterestRateModel is IInterestRateModel, Ownable {
    using SafeDecimalMath for uint256;

    uint256 public constant BLOCKS_PER_YEAR = 2_628_000; // Assuming ~12s block time (adjust for Peaq)
    uint256 private constant UTILIZATION_PRECISION = 1e18; // For utilization ratio
    uint256 private constant BPS_DENOMINATOR = 10000; // For basis points calculations

    // Rates are per block, scaled by 1e18.
    // e.g., 0.0000000237823... for 5% APR (5% / BLOCKS_PER_YEAR)
    uint256 public baseRatePerBlock;
    uint256 public multiplierPerBlock; // Slope before kink
    uint256 public kinkUtilizationRate; // Utilization rate at which the slope changes (scaled by 1e18, e.g., 0.8e18 for 80%)
    uint256 public jumpMultiplierPerBlock; // Additional slope after kink (this is added to multiplierPerBlock)

    event NewInterestParams(
        uint256 baseRatePerBlock,
        uint256 multiplierPerBlock,
        uint256 kinkUtilizationRate,
        uint256 jumpMultiplierPerBlock
    );

    /**
     * @param _baseRateAnnual Annual base borrow rate (e.g., 200 for 2.00%, scaled by 100).
     * @param _multiplierAnnual Annual slope of interest rate before kink (e.g., 900 for 9.00%).
     * @param _kinkUtilizationAnnual Utilization rate at kink (e.g., 8000 for 80.00%).
     * @param _jumpMultiplierAnnual Annual additional slope after kink (e.g., 20000 for 200.00%).
     * @param _owner The owner who can update parameters.
     */
    constructor(
        uint256 _baseRateAnnual,        // e.g., 200 for 2% (scaled by 100 = 1%)
        uint256 _multiplierAnnual,      // e.g., 900 for 9%
        uint256 _kinkUtilizationAnnual, // e.g., 8000 for 80%
        uint256 _jumpMultiplierAnnual,  // e.g., 20000 for 200%
        address _owner
    ) Ownable(_owner) {
        updateModelParameters(_baseRateAnnual, _multiplierAnnual, _kinkUtilizationAnnual, _jumpMultiplierAnnual);
    }

    /**
     * @notice Updates the parameters of the interest rate model.
     * @dev Only callable by the owner. All rates are annual percentages scaled by 100 (1% = 100).
     */
    function updateModelParameters(
        uint256 _baseRateAnnual,
        uint256 _multiplierAnnual,
        uint256 _kinkUtilizationAnnual,
        uint256 _jumpMultiplierAnnual
    ) public onlyOwner {
        require(_kinkUtilizationAnnual <= 10000, "IRM: Kink too high"); // Max 100%

        // Convert annual percentage rates (scaled by 100) to per-block rates (scaled by 1e18)
        // Rate per block = (AnnualRate / 100 (to get decimal) / 100 (if input is %*100) ) / BLOCKS_PER_YEAR * 1e18
        // Rate per block = (AnnualRateScaledBy100 / (100 * 100) / BLOCKS_PER_YEAR) * 1e18
        // Rate per block = (AnnualRateScaledBy100 * 1e18) / (10000 * BLOCKS_PER_YEAR)
        uint256 denominator = BPS_DENOMINATOR * BLOCKS_PER_YEAR; // 10000 (for BPS) * blocks

        baseRatePerBlock = (_baseRateAnnual * UTILIZATION_PRECISION) / denominator;
        multiplierPerBlock = (_multiplierAnnual * UTILIZATION_PRECISION) / denominator;
        jumpMultiplierPerBlock = (_jumpMultiplierAnnual * UTILIZATION_PRECISION) / denominator;
        kinkUtilizationRate = (_kinkUtilizationAnnual * UTILIZATION_PRECISION) / BPS_DENOMINATOR; // Kink is 0-1e18

        emit NewInterestParams(baseRatePerBlock, multiplierPerBlock, kinkUtilizationRate, jumpMultiplierPerBlock);
    }


    /**
     * @inheritdoc IInterestRateModel
     * @dev Calculates borrow rate: base + (slope1 * utilization) [+ slope2 * (utilization - kink)]
     */
    function getBorrowRate(
        uint256 underlyingBalance, // Cash available in the uToken contract
        uint256 totalBorrows,      // Total amount borrowed from this market
        uint256 /*totalReserves*/  // Reserves are not directly used in this model's borrow rate calculation
    ) external view override returns (uint256) {
        if (totalBorrows == 0) { // No borrows, utilization is 0
            return baseRatePerBlock;
        }

        uint256 utilizationRatio = calculateUtilizationRatio(underlyingBalance, totalBorrows);
        uint256 borrowRate = baseRatePerBlock;

        if (utilizationRatio <= kinkUtilizationRate) {
            // rate = (utilization * multiplierPerBlock) + baseRatePerBlock
            borrowRate += utilizationRatio.multiplyDecimal(multiplierPerBlock);
        } else {
            // rate = (kinkUtilization * multiplierPerBlock) + ((utilization - kinkUtilization) * jumpMultiplierPerBlock) + baseRatePerBlock
            uint256 normalRateAtKink = kinkUtilizationRate.multiplyDecimal(multiplierPerBlock);
            uint256 excessUtilization = utilizationRatio - kinkUtilizationRate;
            uint256 jumpRate = excessUtilization.multiplyDecimal(jumpMultiplierPerBlock);
            borrowRate += normalRateAtKink + jumpRate;
        }
        return borrowRate;
    }

    /**
     * @inheritdoc IInterestRateModel
     * @dev Supply Rate = Borrow Rate * Utilization Rate * (1 - Reserve Factor)
     */
    function getSupplyRate(
        uint256 underlyingBalance,
        uint256 totalBorrows,
        uint256 totalReserves,
        uint256 reserveFactorMantissa // Scaled by 1e18 (e.g., 0.1e18 for 10%)
    ) external view override returns (uint256) {
        if (totalBorrows == 0 && underlyingBalance == 0) return 0; // No activity

        uint256 oneMinusReserveFactor = UTILIZATION_PRECISION - reserveFactorMantissa; // Assuming reserveFactorMantissa <= 1e18
        uint256 borrowRate = this.getBorrowRate(underlyingBalance, totalBorrows, totalReserves);
        uint256 utilizationRatio = calculateUtilizationRatio(underlyingBalance, totalBorrows);

        // supplyRate = borrowRate * utilizationRatio * (1 - reserveFactor)
        // All scaled by 1e18, so intermediate products need division by 1e18
        uint256 interimRate = borrowRate.multiplyDecimal(utilizationRatio);
        uint256 supplyRate = interimRate.multiplyDecimal(oneMinusReserveFactor);

        return supplyRate;
    }

    /**
     * @notice Calculates the utilization ratio of the market.
     * @dev Utilization = TotalBorrows / (UnderlyingBalanceInPool + TotalBorrows - TotalReserves)
     *      If TotalReserves are considered part of liquidity available for borrow, then:
     *      Utilization = TotalBorrows / (UnderlyingBalanceInPool + TotalBorrows)
     *      Compound's model: Util = Borrows / (Cash + Borrows - Reserves). Assuming reserves are not borrowable.
     *      Aave's model: Util = TotalBorrows / TotalLiquidityAvailable (which is cash for lending).
     *      Let's use the simpler: Borrows / (Cash + Borrows). This means utilization can reach 100%.
     * @return Utilization ratio, scaled by 1e18 (UTILIZATION_PRECISION).
     */
    function calculateUtilizationRatio(
        uint256 underlyingBalance,
        uint256 totalBorrows
    ) public pure returns (uint256) {
        if (totalBorrows == 0) {
            return 0; // No borrows, utilization is 0
        }
        // utilization = totalBorrows / (totalBorrows + underlyingBalance)
        uint256 totalLiquidity = totalBorrows + underlyingBalance;
        if (totalLiquidity == 0) return 0; // Should not happen if totalBorrows > 0

        return totalBorrows.divideDecimal(totalLiquidity); // Results in a 1e18 scaled value
    }
}
### File: packages/contracts/lend/LendLiquidationEngine.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
// IERC20 and SafeERC20 are not directly needed here if CorePool handles all token movements based on approvals.
import "@openzeppelin/contracts/utils/math/Math.sol";

import "./CorePool.sol"; // For interacting with CorePool
import "./LendRiskController.sol"; // For risk parameters and health checks
import "../common/interfaces/IOracleRelayer.sol"; // For prices
// SafeDecimalMath is not strictly needed here if Math.mulDiv covers needs.

/**
 * @title LendLiquidationEngine
 * @author Unxversal Team
 * @notice Handles liquidation of undercollateralized borrows in Unxversal Lend.
 * @dev Keepers call `liquidate`. Liquidator repays borrower's debt and seizes collateral at a bonus.
 *      Liquidator must approve CorePool for the debt asset they are repaying.
 */
contract LendLiquidationEngine is Ownable, ReentrancyGuard, Pausable {
    CorePool public corePool;
    LendRiskController public riskController;
    IOracleRelayer public oracle;

    // Max percentage of a single borrowed asset's outstanding balance that can be repaid in one liquidation call.
    uint256 public closeFactorBps; // e.g., 5000 for 50% (0-10000 BPS)

    event LiquidationCall(
        address indexed liquidator,
        address indexed borrower,
        address indexed debtAssetRepaid,
        uint256 amountDebtRepaid,       // In debt asset's native decimals
        address indexed collateralAssetSeized,
        uint256 amountCollateralSeized, // In collateral asset's native decimals
        uint256 debtRepaidUsdValue,     // USD value of debt repaid (1e18 scaled)
        uint256 collateralSeizedUsdValue // USD value of collateral seized (1e18 scaled, includes bonus)
    );

    event CorePoolSet(address indexed poolAddress);
    event RiskControllerSet(address indexed controllerAddress);
    event OracleSet(address indexed oracleAddress);
    event CloseFactorSet(uint256 newCloseFactorBps);

    constructor(
        address _corePoolAddress,
        address _riskControllerAddress,
        address _oracleAddress,
        address _initialOwner
    ) Ownable(_initialOwner) {
        setCorePool(_corePoolAddress); // Emits
        setRiskController(_riskControllerAddress); // Emits
        setOracle(_oracleAddress); // Emits
        // closeFactorBps is set by owner post-deployment
    }

    // --- Admin Functions ---
    function setCorePool(address _newPoolAddress) public onlyOwner {
        require(_newPoolAddress != address(0), "LLE: Zero CorePool");
        corePool = CorePool(_newPoolAddress);
        emit CorePoolSet(_newPoolAddress);
    }

    function setRiskController(address _newControllerAddress) public onlyOwner {
        require(_newControllerAddress != address(0), "LLE: Zero RiskController");
        riskController = LendRiskController(_newControllerAddress);
        emit RiskControllerSet(_newControllerAddress);
    }

    function setOracle(address _newOracleAddress) public onlyOwner {
        require(_newOracleAddress != address(0), "LLE: Zero Oracle");
        oracle = IOracleRelayer(_newOracleAddress);
        emit OracleSet(_newOracleAddress);
    }

    function setCloseFactor(uint256 _newCloseFactorBps) external onlyOwner {
        require(_newCloseFactorBps > 0 && _newCloseFactorBps <= LendRiskController.BPS_DENOMINATOR,
            "LLE: Invalid close factor");
        closeFactorBps = _newCloseFactorBps;
        emit CloseFactorSet(_newCloseFactorBps);
    }

    function pauseEngine() external onlyOwner { _pause(); } // Pauses new liquidations
    function unpauseEngine() external onlyOwner { _unpause(); }


    // --- Liquidation Function ---
    /**
     * @notice Liquidates an unhealthy borrow position.
     * @param borrower The address of the account to liquidate.
     * @param debtAssetToRepay The address of the underlying token for the debt being repaid.
     * @param collateralAssetToSeize The address of the underlying token for the collateral being seized.
     * @param amountToRepay The amount of `debtAssetToRepay` the liquidator wishes to repay.
     *                      The liquidator (`msg.sender`) must have approved `CorePool` to spend this amount.
     */
    function liquidate(
        address borrower,
        address debtAssetToRepay,
        address collateralAssetToSeize,
        uint256 amountToRepay // In native decimals of debtAssetToRepay
    ) external nonReentrant whenNotPaused { // Note: whenNotPaused applies to this engine. CorePool might have its own pause state.
        // Check if dependencies are set
        require(address(corePool) != address(0), "LLE: CorePool not set");
        require(address(riskController) != address(0), "LLE: RiskController not set");
        require(address(oracle) != address(0), "LLE: Oracle not set");
        require(closeFactorBps > 0, "LLE: Close factor not set");
        require(amountToRepay > 0, "LLE: Repay amount is zero");

        // 1. Verify borrower is liquidatable (via RiskController)
        require(riskController.isAccountLiquidatable(borrower), "LLE: Account not liquidatable");

        // 2. Get market configs from RiskController
        LendRiskController.MarketRiskConfig memory debtConfig = riskController.marketRiskConfigs(debtAssetToRepay);
        LendRiskController.MarketRiskConfig memory collConfig = riskController.marketRiskConfigs(collateralAssetToSeize);
        require(debtConfig.isListed, "LLE: Debt asset not listed");
        require(collConfig.isListed && collConfig.canBeCollateral, "LLE: Collateral asset not valid");

        // 3. Accrue interest for relevant markets in CorePool before reading balances
        // Note: CorePool's repayBorrowBehalfByEngine and seizeAndTransferCollateral should handle their own accruals.
        // It's safer for CorePool to manage its accruals internally before any state change.
        // So, this engine doesn't need to explicitly call accrueInterest if CorePool's methods do.
        // Let's assume CorePool's relevant methods (called below) handle accrual.

        // 4. Determine actual amount of debt to repay
        // Query CorePool for current borrow balance (after its internal accrual)
        (, uint256 borrowerDebtBalance) = corePool.getUserSupplyAndBorrowBalance(borrower, debtAssetToRepay);
        require(borrowerDebtBalance > 0, "LLE: Borrower has no debt for this asset");

        uint256 maxRepayableByCloseFactor = Math.mulDiv(borrowerDebtBalance, closeFactorBps, LendRiskController.BPS_DENOMINATOR);
        uint256 actualAmountDebtToRepay = Math.min(amountToRepay, maxRepayableByCloseFactor);
        actualAmountDebtToRepay = Math.min(actualAmountDebtToRepay, borrowerDebtBalance);
        require(actualAmountDebtToRepay > 0, "LLE: Calculated repay amount is zero");

        // 5. Calculate USD value of the debt being repaid
        uint256 debtAssetPrice = oracle.getPrice(debtConfig.oracleAssetId); // 1e18 scaled USD per whole unit
        uint256 debtRepaidUsdValue = Math.mulDiv(actualAmountDebtToRepay, debtAssetPrice, (10**debtConfig.underlyingDecimals));
        require(debtRepaidUsdValue > 0, "LLE: Debt repaid USD value is zero");

        // 6. Calculate USD value of collateral to seize (debt repaid + bonus from collateral asset's config)
        uint256 liquidationBonusBps = collConfig.liquidationBonusBps;
        require(liquidationBonusBps > 0, "LLE: Liquidation bonus not set for collateral"); // Bonus should typically be > 0

        uint256 bonusValueUsd = Math.mulDiv(debtRepaidUsdValue, liquidationBonusBps, LendRiskController.BPS_DENOMINATOR);
        uint256 totalCollateralToSeizeUsdValue = debtRepaidUsdValue + bonusValueUsd;

        // 7. Convert seizeable USD value to amount of collateral asset
        uint256 collateralAssetPrice = oracle.getPrice(collConfig.oracleAssetId);
        require(collateralAssetPrice > 0, "LLE: Collateral price is zero");
        uint256 amountCollateralToSeize = Math.mulDiv(totalCollateralToSeizeUsdValue, (10**collConfig.underlyingDecimals), collateralAssetPrice);
        require(amountCollateralToSeize > 0, "LLE: Calculated seize amount is zero");

        // 8. Liquidator (msg.sender) must have approved CorePool for `actualAmountDebtToRepay` of `debtAssetToRepay`.
        // This engine calls CorePool to execute the repayment on behalf of the liquidator.
        corePool.repayBorrowBehalfByEngine(
            _msgSender(),               // liquidator (payer)
            borrower,                   // borrower whose debt is reduced
            debtAssetToRepay,
            actualAmountDebtToRepay
        );
        // Note: repayBorrowBehalfByEngine in CorePool handles:
        // - Accruing interest for the debt market.
        // - Pulling `actualAmountDebtToRepay` of `debtAssetToRepay` from `liquidator` to the debt asset's `uToken`.
        // - Updating `borrower`'s borrow balance and market's `totalBorrowsPrincipal`.

        // 9. CorePool transfers seized collateral (underlying) from borrower's uToken holdings to liquidator
        corePool.seizeAndTransferCollateral(
            borrower,
            _msgSender(), // liquidator (recipient of collateral)
            collateralAssetToSeize,
            amountCollateralToSeize
        );
        // Note: seizeAndTransferCollateral in CorePool handles:
        // - Accruing interest for the collateral market.
        // - Calculating uTokens to burn from borrower based on `amountCollateralToSeize` and exchange rate.
        // - Burning those uTokens from borrower.
        // - Transferring `amountCollateralToSeize` of `collateralAssetToSeize` (underlying) from its uToken to `liquidator`.

        emit LiquidationCall(
            _msgSender(), borrower, debtAssetToRepay, actualAmountDebtToRepay,
            collateralAssetToSeize, amountCollateralToSeize,
            debtRepaidUsdValue, totalCollateralToSeizeUsdValue
        );
    }
}
### File: packages/contracts/lend/LendAdmin.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../common/access/ProtocolAdminAccess.sol"; // Inherits Ownable
import "./CorePool.sol";
import "./LendRiskController.sol";
import "./uToken.sol";
import "./interestModels/IInterestRateModel.sol";
import "./interestModels/PiecewiseLinearInterestRateModel.sol"; // Example concrete model
import "../common/interfaces/IOracleRelayer.sol";

/**
 * @title LendAdmin
 * @author Unxversal Team
 * @notice Administrative module for the Unxversal Lend protocol.
 * @dev Manages critical parameters for CorePool, LendRiskController, and associated
 *      uTokens and InterestRateModels. Owned by a multisig or DAO Timelock.
 *      This contract will be the owner of CorePool and LendRiskController.
 *      It can also deploy new uTokens and InterestRateModels or register existing ones.
 */
contract LendAdmin is ProtocolAdminAccess {
    CorePool public corePool;
    LendRiskController public lendRiskController;
    IOracleRelayer public oracleRelayer; // For configuring LendRiskController

    // Optional: Addresses of deployed uToken/InterestRateModel implementations for cloning/reference
    // address public uTokenImplementation;
    // address public piecewiseInterestModelImplementation;

    event CorePoolSet(address indexed poolAddress);
    event LendRiskControllerSet(address indexed controllerAddress);
    event OracleRelayerSet(address indexed oracleAddress); // For LRC configuration
    event MarketListedInCorePool(
        address indexed underlyingAsset,
        address indexed uTokenAddress,
        address indexed interestRateModelAddress
    );
    event MarketConfiguredInRiskController(
        address indexed underlyingAsset,
        address uTokenAddress, // Repeated for event clarity
        bool canBeCollateral,
        uint256 collateralFactorBps,
        uint256 liquidationThresholdBps,
        uint256 liquidationBonusBps,
        uint256 oracleAssetId
    );
    event ReserveFactorSet(address indexed underlyingAsset, uint256 newReserveFactorBps);
    event LiquidationEngineSetForCorePool(address indexed engineAddress);


    constructor(
        address _initialOwner,
        address _corePoolAddress,         // Expected to be deployed
        address _lendRiskControllerAddress, // Expected to be deployed
        address _oracleRelayerAddress    // For configuring LRC
    ) ProtocolAdminAccess(_initialOwner) {
        setCorePool(_corePoolAddress);
        setLendRiskController(_lendRiskControllerAddress);
        setOracleRelayer(_oracleRelayerAddress); // Store for LRC setup
    }

    // --- Target Contract Setters ---
    function setCorePool(address _newPoolAddress) public onlyOwner {
        require(_newPoolAddress != address(0), "LendAdmin: Zero CorePool");
        corePool = CorePool(_newPoolAddress);
        emit CorePoolSet(_newPoolAddress);
    }

    function setLendRiskController(address _newControllerAddress) public onlyOwner {
        require(_newControllerAddress != address(0), "LendAdmin: Zero RiskController");
        lendRiskController = LendRiskController(_newControllerAddress);
        emit LendRiskControllerSet(_newControllerAddress);
    }

    function setOracleRelayer(address _newOracleAddress) public onlyOwner {
        require(_newOracleAddress != address(0), "LendAdmin: Zero OracleRelayer for LRC");
        oracleRelayer = IOracleRelayer(_newOracleAddress);
        // Also update it on the LendRiskController if it's already set
        if (address(lendRiskController) != address(0)) {
            lendRiskController.setOracle(_newOracleAddress);
        }
        emit OracleRelayerSet(_newOracleAddress);
    }

    /**
     * @notice Lists a new asset market in the lending protocol.
     * @dev This involves:
     *      1. Deploying a new uToken contract (or using a pre-deployed one).
     *      2. Deploying a new InterestRateModel contract (or using a pre-deployed one).
     *      3. Calling CorePool.listMarket to register the uToken and its IRM.
     *      4. Calling LendRiskController.listMarket to set risk parameters.
     *      This function assumes new uToken and IRM are deployed per market for simplicity.
     *      Production systems might use clone factories for uTokens/IRMs.
     * @param uTokenName Name for the new uToken (e.g., "Unxversal USDC").
     * @param uTokenSymbol Symbol for the new uToken (e.g., "uUSDC").
     * @param underlyingAssetAddr Address of the underlying ERC20 token.
     * @param irmBaseRateAnnual Annual base borrow rate for IRM (e.g., 200 for 2.00%).
     * @param irmMultiplierAnnual Annual slope for IRM (e.g., 900 for 9.00%).
     * @param irmKinkAnnual Kink utilization for IRM (e.g., 8000 for 80.00%).
     * @param irmJumpMultiplierAnnual Annual jump slope for IRM (e.g., 20000 for 200.00%).
     * @param lrcCanBeCollateral True if asset can be collateral in LendRiskController.
     * @param lrcCollateralFactorBps Collateral factor in BPS for LRC.
     * @param lrcLiquidationThresholdBps Liquidation threshold in BPS for LRC.
     * @param lrcLiquidationBonusBps Liquidation bonus in BPS for LRC.
     * @param lrcOracleAssetId Oracle asset ID for LRC (0 to try derive from SynthFactory).
     */
    function listNewMarketFull(
        // uToken params
        string calldata uTokenName,
        string calldata uTokenSymbol,
        address underlyingAssetAddr,
        // InterestRateModel params (PiecewiseLinear for this example)
        uint256 irmBaseRateAnnual,
        uint256 irmMultiplierAnnual,
        uint256 irmKinkAnnual,
        uint256 irmJumpMultiplierAnnual,
        // LendRiskController params
        bool lrcCanBeCollateral,
        uint256 lrcCollateralFactorBps,
        uint256 lrcLiquidationThresholdBps,
        uint256 lrcLiquidationBonusBps,
        uint256 lrcOracleAssetId
    ) external onlyOwner {
        require(address(corePool) != address(0), "LendAdmin: CorePool not set");
        require(address(lendRiskController) != address(0), "LendAdmin: RiskController not set");
        require(underlyingAssetAddr != address(0), "LendAdmin: Zero underlying asset");

        // 1. Deploy new InterestRateModel (PiecewiseLinear example)
        // The owner of the IRM will be this LendAdmin contract.
        PiecewiseLinearInterestRateModel newIrm = new PiecewiseLinearInterestRateModel(
            irmBaseRateAnnual, irmMultiplierAnnual, irmKinkAnnual, irmJumpMultiplierAnnual, address(this)
        );

        // 2. Deploy new uToken
        // The owner of the uToken will be this LendAdmin contract.
        // CorePool needs to be able to call mint/burn on it.
        // uToken constructor: underlying, corePool, name, symbol, admin
        uToken newUToken = new uToken(
            underlyingAssetAddr, address(corePool), uTokenName, uTokenSymbol, address(this)
        );
        // After deployment, uToken owner (this LendAdmin) might need to grant specific roles/permissions
        // to CorePool if uToken methods are restricted beyond msg.sender == corePool.
        // The current uToken has `require(msg.sender == address(corePool))` which is fine.

        // 3. Call CorePool.listMarket
        // This function in CorePool should be onlyOwner (i.e., callable by this LendAdmin)
        corePool.listMarket(underlyingAssetAddr, address(newUToken), address(newIrm));
        emit MarketListedInCorePool(underlyingAssetAddr, address(newUToken), address(newIrm));

        // 4. Call LendRiskController.listMarket
        // This function in LendRiskController should be onlyOwner
        lendRiskController.listMarket(
            underlyingAssetAddr, address(newUToken), lrcCanBeCollateral,
            lrcCollateralFactorBps, lrcLiquidationThresholdBps, lrcLiquidationBonusBps, lrcOracleAssetId
        );
        emit MarketConfiguredInRiskController(
            underlyingAssetAddr, address(newUToken), lrcCanBeCollateral,
            lrcCollateralFactorBps, lrcLiquidationThresholdBps, lrcLiquidationBonusBps, lrcOracleAssetId
        );
    }

    /**
     * @notice Updates risk parameters for an existing market in LendRiskController.
     */
    function updateMarketRiskParameters(
        address underlyingAsset,
        bool canBeCollateral,
        uint256 collateralFactorBps,
        uint256 liquidationThresholdBps,
        uint256 liquidationBonusBps
        // oracleAssetId is updated separately if needed via setMarketOracleAssetId
    ) external onlyOwner {
        require(address(lendRiskController) != address(0), "LendAdmin: RiskController not set");
        // LendRiskController.listMarket can also be used for updates if it handles existing markets.
        // Or add specific update functions in LendRiskController.
        // Assuming LendRiskController.listMarket handles updates by checking if market already listed.
        address uTokenAddr = corePool.getUTokenForUnderlying(underlyingAsset); // Need this for LRC's listMarket
        uint256 currentOracleAssetId = lendRiskController.marketRiskConfigs(underlyingAsset).oracleAssetId; // Preserve current

        lendRiskController.listMarket(
            underlyingAsset, uTokenAddr, canBeCollateral,
            collateralFactorBps, liquidationThresholdBps, liquidationBonusBps, currentOracleAssetId
        );
        // Event is emitted by LendRiskController
    }

    /** @notice Sets the oracle asset ID for a market in LendRiskController. */
    function setMarketOracleAssetIdLRC(address underlyingAsset, uint256 newOracleAssetId) external onlyOwner {
        require(address(lendRiskController) != address(0), "LendAdmin: RiskController not set");
        lendRiskController.setMarketOracleAssetId(underlyingAsset, newOracleAssetId);
    }

    /** @notice Updates the interest rate model parameters for a market. */
    function updateInterestRateModelParams(
        address underlyingAsset, // To find the IRM address via CorePool
        uint256 newBaseRateAnnual,
        uint256 newMultiplierAnnual,
        uint256 newKinkAnnual,
        uint256 newJumpMultiplierAnnual
    ) external onlyOwner {
        require(address(corePool) != address(0), "LendAdmin: CorePool not set");
        address irmAddress = corePool.getInterestRateModelForUnderlying(underlyingAsset);
        require(irmAddress != address(0), "LendAdmin: IRM not found for asset");
        // Assumes IRM is PiecewiseLinear and owned by this LendAdmin contract
        PiecewiseLinearInterestRateModel(payable(irmAddress)).updateModelParameters( // payable for OZ v5 constructor calls in some contexts
            newBaseRateAnnual, newMultiplierAnnual, newKinkAnnual, newJumpMultiplierAnnual
        );
    }
    
    /** @notice Sets a new interest rate model for a market in CorePool. */
    function setMarketInterestRateModel(address underlyingAsset, address newIrmAddress) external onlyOwner {
        require(address(corePool) != address(0), "LendAdmin: CorePool not set");
        // CorePool must have a setter for this, callable by its owner (this LendAdmin)
        corePool.setInterestRateModel(underlyingAsset, newIrmAddress);
    }

    /** @notice Sets the reserve factor for a market in CorePool. */
    function setMarketReserveFactor(address underlyingAsset, uint256 newReserveFactorBps) external onlyOwner {
        require(address(corePool) != address(0), "LendAdmin: CorePool not set");
        // CorePool must have a setter, callable by its owner
        corePool.setReserveFactor(underlyingAsset, newReserveFactorBps);
        emit ReserveFactorSet(underlyingAsset, newReserveFactorBps); // Or CorePool emits this
    }

    /** @notice Sets the LiquidationEngine address on CorePool. */
    function setCorePoolLiquidationEngine(address engineAddress) external onlyOwner {
        require(address(corePool) != address(0), "LendAdmin: CorePool not set");
        corePool.setLiquidationEngine(engineAddress);
        emit LiquidationEngineSetForCorePool(engineAddress);
    }

    // --- Ownership Transfers of Core Lend Contracts ---
    function transferCorePoolOwnership(address newOwner) external onlyOwner {
        require(address(corePool) != address(0), "LendAdmin: CorePool not set");
        corePool.transferOwnership(newOwner);
    }

    function transferLendRiskControllerOwnership(address newOwner) external onlyOwner {
        require(address(lendRiskController) != address(0), "LendAdmin: RiskController not set");
        lendRiskController.transferOwnership(newOwner);
    }

    // --- Protocol Pause (delegated to CorePool) ---
    // CorePool would implement Pausable and pause its core functions.
    function pauseLendProtocol() external onlyOwner {
        require(address(corePool) != address(0), "LendAdmin: CorePool not set");
        corePool.pause(); // Assuming CorePool has pause()
    }

    function unpauseLendProtocol() external onlyOwner {
        require(address(corePool) != address(0), "LendAdmin: CorePool not set");
        corePool.unpause(); // Assuming CorePool has unpause()
    }
}
### File: packages/contracts/lend/LendRiskController.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol"; // For decimals()
import "../common/interfaces/IOracleRelayer.sol";
import "./interfaces/ICorePoolLens.sol";
import "./uToken.sol"; // To cast uToken address and call exchangeRateStored
import "../synth/SynthFactory.sol"; // Optional, for sAsset oracleAssetId resolution
// SafeDecimalMath is not strictly needed here if we use Math.mulDiv correctly for all price scaling.

/**
 * @title LendRiskController
 * @author Unxversal Team
 * @notice Manages risk parameters and calculates account health for Unxversal Lend.
 */
contract LendRiskController is Ownable {
    struct MarketRiskConfig {
        bool isListed;
        bool canBeCollateral;
        uint256 collateralFactorBps;    // e.g., 7500 for 75%
        uint256 liquidationThresholdBps;// e.g., 8000 for 80%
        uint256 liquidationBonusBps;    // e.g., 500 for 5%
        address uTokenAddress;
        uint256 oracleAssetId;          // Resolved ID for the oracle
        uint8 underlyingDecimals;       // Decimals of the underlying asset
    }

    mapping(address => MarketRiskConfig) public marketRiskConfigs; // underlyingAssetAddress => Config
    address[] public listedAssets;

    ICorePoolLens public corePool;
    IOracleRelayer public oracle;
    SynthFactory public synthFactory; // Optional

    uint256 public constant BPS_DENOMINATOR = 10000;
    uint256 public constant PRICE_PRECISION = 1e18; // Oracle prices and internal USD values are 1e18 scaled
    uint256 public constant HEALTH_FACTOR_PRECISION = 1e18;

    event MarketListed(address indexed underlyingAsset, address indexed uToken, uint256 cfBps, uint256 ltBps);
    event MarketConfigUpdated(address indexed underlyingAsset, uint256 cfBps, uint256 ltBps, uint256 lqBonusBps);
    event OracleAssetIdSet(address indexed underlyingAsset, uint256 oracleAssetId);
    event CorePoolSet(address indexed corePoolAddress);
    event OracleSet(address indexed oracleAddress);
    event SynthFactorySet(address indexed factoryAddress);

    constructor(
        address _corePoolAddress, address _oracleAddress,
        address _synthFactoryAddress, address _initialOwner
    ) Ownable(_initialOwner) {
        setCorePool(_corePoolAddress); // Emits event
        setOracle(_oracleAddress);   // Emits event
        if (_synthFactoryAddress != address(0)) {
            setSynthFactory(_synthFactoryAddress); // Emits event
        }
    }

    function setCorePool(address _corePoolAddress) public onlyOwner {
        require(_corePoolAddress != address(0), "LRC: Zero CorePool");
        corePool = ICorePoolLens(_corePoolAddress);
        emit CorePoolSet(_corePoolAddress);
    }

    function setOracle(address _oracleAddress) public onlyOwner {
        require(_oracleAddress != address(0), "LRC: Zero oracle");
        oracle = IOracleRelayer(_oracleAddress);
        emit OracleSet(_oracleAddress);
    }

    function setSynthFactory(address _factoryAddress) public onlyOwner {
        synthFactory = SynthFactory(_factoryAddress); // Allow address(0) to disable
        emit SynthFactorySet(_factoryAddress);
    }

    function listMarket(
        address underlyingAsset, address _uTokenAddress, bool _canBeCollateral,
        uint256 _cfBps, uint256 _ltBps, uint256 _lqBonusBps, uint256 _oracleAssetId
    ) external onlyOwner {
        require(underlyingAsset != address(0), "LRC: Zero underlying");
        require(_uTokenAddress != address(0), "LRC: Zero uToken");
        require(_cfBps <= _ltBps, "LRC: CF > LT");
        require(_ltBps <= BPS_DENOMINATOR, "LRC: LT too high");
        require(_lqBonusBps <= BPS_DENOMINATOR / 4, "LRC: Bonus too high"); // Max 25% bonus example

        MarketRiskConfig storage config = marketRiskConfigs[underlyingAsset];
        uint256 resolvedOracleId = _oracleAssetId;
        uint8 underlyingDecs = IERC20(underlyingAsset).decimals(); // Fetch decimals

        if (resolvedOracleId == 0 && address(synthFactory) != address(0) && synthFactory.isSynthRegistered(underlyingAsset)) {
            SynthFactory.SynthConfig memory synthConf = synthFactory.getSynthConfig(underlyingAsset);
            resolvedOracleId = synthConf.assetId;
        }
        require(resolvedOracleId != 0, "LRC: Oracle ID not resolved");

        if (!config.isListed) {
            config.isListed = true;
            listedAssets.push(underlyingAsset);
            emit MarketListed(underlyingAsset, _uTokenAddress, _cfBps, _ltBps);
        }
        
        config.uTokenAddress = _uTokenAddress;
        config.canBeCollateral = _canBeCollateral;
        config.collateralFactorBps = _cfBps;
        config.liquidationThresholdBps = _ltBps;
        config.liquidationBonusBps = _lqBonusBps;
        config.oracleAssetId = resolvedOracleId;
        config.underlyingDecimals = underlyingDecs;

        emit MarketConfigUpdated(underlyingAsset, _cfBps, _ltBps, _lqBonusBps);
        if (_oracleAssetId != resolvedOracleId || config.oracleAssetId != resolvedOracleId) { // If it changed
             emit OracleAssetIdSet(underlyingAsset, resolvedOracleId);
        }
    }
    
    function setMarketOracleAssetId(address underlyingAsset, uint256 newOracleAssetId) external onlyOwner {
        MarketRiskConfig storage config = marketRiskConfigs[underlyingAsset];
        require(config.isListed, "LRC: Market not listed");
        require(newOracleAssetId != 0, "LRC: Zero oracle assetId");
        config.oracleAssetId = newOracleAssetId;
        emit OracleAssetIdSet(underlyingAsset, newOracleAssetId);
    }

    function getAccountLiquidityValues(address user)
        public view
        returns (uint256 totalCollateralValueUsd, uint256 totalBorrowValueUsd)
    {
        require(address(corePool) != address(0) && address(oracle) != address(0), "LRC: Not initialized");

        address[] memory suppliedAssets = corePool.getAssetsUserSupplied(user);
        address[] memory borrowedAssets = corePool.getAssetsUserBorrowed(user);

        for (uint i = 0; i < suppliedAssets.length; i++) {
            address underlying = suppliedAssets[i];
            MarketRiskConfig storage config = marketRiskConfigs[underlying];
            if (config.isListed && config.canBeCollateral) {
                (uint256 uTokenBalance, ) = corePool.getUserSupplyAndBorrowBalance(user, underlying);
                if (uTokenBalance > 0) {
                    uToken uTokenContract = uToken(payable(config.uTokenAddress));
                    uint256 underlyingSupplied = Math.mulDiv(uTokenBalance, uTokenContract.exchangeRateStored(), PRICE_PRECISION);
                    uint256 price = oracle.getPrice(config.oracleAssetId); // Assumes price is 1e18 scaled USD per WHOLE unit
                    
                    uint256 supplyUsd = Math.mulDiv(underlyingSupplied, price, (10**config.underlyingDecimals));
                    uint256 collateralContrib = Math.mulDiv(supplyUsd, config.collateralFactorBps, BPS_DENOMINATOR);
                    totalCollateralValueUsd += collateralContrib;
                }
            }
        }

        for (uint i = 0; i < borrowedAssets.length; i++) {
            address underlying = borrowedAssets[i];
            MarketRiskConfig storage config = marketRiskConfigs[underlying]; // Must be listed if borrowed
            if(config.isListed){ // Should always be true
                (, uint256 borrowBalance) = corePool.getUserSupplyAndBorrowBalance(user, underlying);
                if (borrowBalance > 0) {
                    uint256 price = oracle.getPrice(config.oracleAssetId);
                    uint256 borrowUsd = Math.mulDiv(borrowBalance, price, (10**config.underlyingDecimals));
                    totalBorrowValueUsd += borrowUsd;
                }
            }
        }
    }

    function getAccountLiquidity(address user) public view returns (int256 liquidityUsd) {
        (uint256 collUsd, uint256 borrUsd) = getAccountLiquidityValues(user);
        if (collUsd >= borrUsd) {
            return int256(collUsd - borrUsd);
        } else {
            return -int256(borrUsd - collUsd);
        }
    }

    function getHealthFactor(address user) public view returns (uint256 healthFactor) {
        (uint256 collUsd, uint256 borrUsd) = getAccountLiquidityValues(user);
        if (borrUsd == 0) return type(uint256).max; // Infinite health
        return Math.mulDiv(collUsd, HEALTH_FACTOR_PRECISION, borrUsd);
    }

    function isAccountLiquidatable(address user) public view returns (bool) {
        require(address(corePool) != address(0) && address(oracle) != address(0), "LRC: Not initialized");
        uint256 totalCollateralAtLTUsd = 0;
        uint256 totalBorrUsd = 0;

        address[] memory suppliedAssets = corePool.getAssetsUserSupplied(user);
        address[] memory borrowedAssets = corePool.getAssetsUserBorrowed(user);

        for (uint i = 0; i < suppliedAssets.length; i++) {
            address underlying = suppliedAssets[i];
            MarketRiskConfig storage config = marketRiskConfigs[underlying];
            if (config.isListed && config.canBeCollateral) {
                (uint256 uTokenBalance, ) = corePool.getUserSupplyAndBorrowBalance(user, underlying);
                if (uTokenBalance > 0) {
                    uToken uTokenContract = uToken(payable(config.uTokenAddress));
                    uint256 underlyingSupplied = Math.mulDiv(uTokenBalance, uTokenContract.exchangeRateStored(), PRICE_PRECISION);
                    uint256 price = oracle.getPrice(config.oracleAssetId);
                    uint256 supplyUsd = Math.mulDiv(underlyingSupplied, price, (10**config.underlyingDecimals));
                    uint256 collateralAtLT = Math.mulDiv(supplyUsd, config.liquidationThresholdBps, BPS_DENOMINATOR);
                    totalCollateralAtLTUsd += collateralAtLT;
                }
            }
        }

        for (uint i = 0; i < borrowedAssets.length; i++) {
            address underlying = borrowedAssets[i];
             MarketRiskConfig storage config = marketRiskConfigs[underlying];
            if(config.isListed){
                (, uint256 borrowBalance) = corePool.getUserSupplyAndBorrowBalance(user, underlying);
                if (borrowBalance > 0) {
                    uint256 price = oracle.getPrice(config.oracleAssetId);
                    uint256 borrowUsd = Math.mulDiv(borrowBalance, price, (10**config.underlyingDecimals));
                    totalBorrUsd += borrowUsd;
                }
            }
        }
        if (totalBorrUsd == 0) return false;
        return totalCollateralAtLTUsd < totalBorrUsd;
    }

    function preBorrowCheck(address user, address assetToBorrow, uint256 amountToBorrow) external view {
        MarketRiskConfig storage borrowCfg = marketRiskConfigs[assetToBorrow];
        require(borrowCfg.isListed, "LRC: Borrow asset not listed");
        
        (uint256 totalCollUsd, uint256 currentBorrUsd) = getAccountLiquidityValues(user);
        
        uint256 priceBorrowAsset = oracle.getPrice(borrowCfg.oracleAssetId);
        uint256 amountToBorrowUsd = Math.mulDiv(amountToBorrow, priceBorrowAsset, (10**borrowCfg.underlyingDecimals));
        uint256 newTotalBorrUsd = currentBorrUsd + amountToBorrowUsd;
        
        require(totalCollUsd >= newTotalBorrUsd, "LRC: Borrow exceeds collateral capacity");
    }

    function preWithdrawCheck(address user, address assetCollateral, uint256 amountCollateralToWithdraw) external view {
        MarketRiskConfig storage collCfg = marketRiskConfigs[assetCollateral];
        require(collCfg.isListed && collCfg.canBeCollateral, "LRC: Asset not valid collateral");

        (uint256 currentTotalCollUsd, uint256 totalBorrUsd) = getAccountLiquidityValues(user);
        if (totalBorrUsd == 0) return; // No borrows, can withdraw

        uint256 priceCollAsset = oracle.getPrice(collCfg.oracleAssetId);
        uint256 valueToWithdrawUsd = Math.mulDiv(amountCollateralToWithdraw, priceCollAsset, (10**collCfg.underlyingDecimals));
        
        // Calculate the reduction in borrowing power this withdrawal represents
        uint256 borrowingPowerReduction = Math.mulDiv(valueToWithdrawUsd, collCfg.collateralFactorBps, BPS_DENOMINATOR);

        require(currentTotalCollUsd > borrowingPowerReduction, "LRC: Not enough coll value to remove that much power");
        uint256 newTotalCollUsd = currentTotalCollUsd - borrowingPowerReduction;
        
        require(newTotalCollUsd >= totalBorrUsd, "LRC: Withdrawal makes position undercollateralized");
    }
    
    function getListedAssetsCount() external view returns (uint256) { return listedAssets.length; }
    function getListedAssetAtIndex(uint256 index) external view returns (address) { return listedAssets[index]; }
}
### File: packages/contracts/lend/interfaces/ICorePoolLens.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title ICorePoolLens
 * @author Unxversal Team
 * @notice Minimal interface for LendRiskController to query user balances from CorePool.
 */
interface ICorePoolLens {
    /**
     * @notice Gets a user's supply balance (in uTokens) and borrow balance (in underlying) for a specific asset.
     * @param user The user's address.
     * @param underlyingAsset The address of the underlying asset for the market.
     * @return uTokenSupplyBalance The amount of uTokens the user holds for this market.
     * @return underlyingBorrowBalance The amount of underlying asset the user has borrowed from this market.
     */
    function getUserSupplyAndBorrowBalance(address user, address underlyingAsset)
        external view returns (uint256 uTokenSupplyBalance, uint256 underlyingBorrowBalance);

    /**
     * @notice Gets all assets a user has supplied uTokens for.
     * @param user The user's address.
     * @return An array of underlying asset addresses.
     */
    function getAssetsUserSupplied(address user) external view returns (address[] memory);

    /**
     * @notice Gets all assets a user has borrowed.
     * @param user The user's address.
     * @return An array of underlying asset addresses.
     */
    function getAssetsUserBorrowed(address user) external view returns (address[] memory);

    // Potentially other views LendRiskController might need from CorePool:
    // function getMarketInfo(address underlyingAsset) external view returns (...);
    // function uTokenAddress(address underlyingAsset) external view returns (address);
}
### File: packages/contracts/dao/GuardianPause.sol

### File: packages/contracts/dao/Governor.sol

### File: packages/contracts/dao/GaugeController.sol

### File: packages/contracts/dao/UNXV.sol

### File: packages/contracts/dao/TimelockController.sol

### File: packages/contracts/dao/veUNXV.sol

### File: packages/contracts/dao/Treasury.sol

### File: packages/contracts/common/access/ProtocolAdminAccess.sol
// contracts/common/access/ProtocolAdminAccess.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";

/// @dev Base admin/owner helper for protocol contracts.
abstract contract ProtocolAdminAccess is Ownable {
    constructor(address initialOwner)
        Ownable(initialOwner)             // <-- forward the argument
    {
        require(initialOwner != address(0), "ProtocolAdminAccess: zero address");
        // Ownable already sets the owner, so no extra transfer needed.
        // _transferOwnership(initialOwner);   // <- remove (or keep; it’s harmless but redundant)
    }
}

### File: packages/contracts/common/libraries/SafeDecimalMath.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/math/Math.sol";

/**
 * @title SafeDecimalMath
 * @author Unxversal Team (inspired by various fixed-point math libraries)
 * @notice Library for performing common arithmetic operations with fixed-point decimal numbers.
 * @dev Assumes that decimal numbers are represented as uint256 integers with a fixed number
 *      of decimal places, typically 18 (WAD) or as defined by `getDecimalPrecision()`.
 *      Uses OpenZeppelin's Math.Rounding for division.
 */
library SafeDecimalMath {
    // Default precision for numbers if not otherwise specified (e.g., 10^18 for WAD)
    uint256 private constant DEFAULT_DECIMAL_PRECISION = 1e18;

    // Error messages
    string private constant ERROR_DIV_BY_ZERO = "SafeDecimalMath: Division by zero";
    string private constant ERROR_MUL_OVERFLOW = "SafeDecimalMath: Multiplication overflow";

    /**
     * @notice Returns the standard decimal precision used by this library (10^18).
     */
    function getDecimalPrecision() internal pure returns (uint256) {
        return DEFAULT_DECIMAL_PRECISION;
    }

    /**
     * @notice Multiplies two decimal numbers, maintaining precision.
     * @dev x * y / precision
     * @param x The first decimal number.
     * @param y The second decimal number.
     * @return The product, scaled to the standard precision.
     */
    function multiplyDecimal(uint256 x, uint256 y) internal pure returns (uint256) {
        return Math.mulDiv(x, y, DEFAULT_DECIMAL_PRECISION, Math.Rounding.Floor);
    }

    /**
     * @notice Multiplies two decimal numbers, maintaining precision, with specific rounding.
     * @dev x * y / precision
     * @param x The first decimal number.
     * @param y The second decimal number.
     * @param rounding The rounding mode to use (Up, Down, Celling, Floor from OZ Math).
     * @return The product, scaled to the standard precision.
     */
    function multiplyDecimal(uint256 x, uint256 y, Math.Rounding rounding) internal pure returns (uint256) {
        return Math.mulDiv(x, y, DEFAULT_DECIMAL_PRECISION, rounding);
    }


    /**
     * @notice Divides one decimal number by another, maintaining precision.
     * @dev (x * precision) / y
     * @param x The numerator (decimal number).
     * @param y The denominator (decimal number).
     * @return The quotient, scaled to the standard precision.
     */
    function divideDecimal(uint256 x, uint256 y) internal pure returns (uint256) {
        require(y > 0, ERROR_DIV_BY_ZERO);
        return Math.mulDiv(x, DEFAULT_DECIMAL_PRECISION, y, Math.Rounding.Floor);
    }

    /**
     * @notice Divides one decimal number by another, maintaining precision, with specific rounding.
     * @dev (x * precision) / y
     * @param x The numerator (decimal number).
     * @param y The denominator (decimal number).
     * @param rounding The rounding mode to use (Up, Down, Celling, Floor from OZ Math).
     * @return The quotient, scaled to the standard precision.
     */
    function divideDecimal(uint256 x, uint256 y, Math.Rounding rounding) internal pure returns (uint256) {
        require(y > 0, ERROR_DIV_BY_ZERO);
        return Math.mulDiv(x, DEFAULT_DECIMAL_PRECISION, y, rounding);
    }

    /**
     * @notice Calculates a percentage of a decimal value.
     * @dev (value * percentageBps) / (BPS_DENOMINATOR * precision_factor_if_percentage_is_decimal)
     *      If percentageBps is a whole number percentage * 100 (e.g., 500 for 5%),
     *      then this is effectively (value * percentageBps) / 10000.
     *      The result maintains the precision of `value`.
     * @param value The decimal value to take the percentage of.
     * @param percentageBps The percentage in basis points (1% = 100 bps).
     * @return The calculated percentage of the value.
     */
    function calculatePercentage(uint256 value, uint256 percentageBps) internal pure returns (uint256) {
        uint256 BPS_PRECISION = 10000; // Basis points denominator
        // (value * percentageBps) / BPS_PRECISION
        // Math.mulDiv already handles scaling correctly.
        return Math.mulDiv(value, percentageBps, BPS_PRECISION, Math.Rounding.Floor);
    }

    /**
     * @notice Adds two decimal numbers.
     * @dev Standard addition, assumes both inputs have the same precision.
     * @param x The first decimal number.
     * @param y The second decimal number.
     * @return The sum.
     */
    function addDecimal(uint256 x, uint256 y) internal pure returns (uint256) {
        uint256 z = x + y;
        require(z >= x, "SafeDecimalMath: Addition overflow"); // Check for overflow
        return z;
    }

    /**
     * @notice Subtracts one decimal number from another.
     * @dev Standard subtraction, assumes both inputs have the same precision.
     * @param x The number to subtract from.
     * @param y The number to subtract.
     * @return The difference.
     */
    function subtractDecimal(uint256 x, uint256 y) internal pure returns (uint256) {
        require(x >= y, "SafeDecimalMath: Subtraction underflow"); // Check for underflow
        return x - y;
    }

    /**
     * @notice Converts a number to the standard decimal precision (e.g., if input is a whole number).
     * @param x The number to convert.
     * @return x scaled by the decimal precision.
     */
    function toDecimal(uint256 x) internal pure returns (uint256) {
        // x * DEFAULT_DECIMAL_PRECISION / 1
        // Check for overflow before multiplication
        if (x == 0) return 0;
        require(DEFAULT_DECIMAL_PRECISION <= type(uint256).max / x, ERROR_MUL_OVERFLOW);
        return x * DEFAULT_DECIMAL_PRECISION;
    }

    /**
     * @notice Converts a number from the standard decimal precision to a whole number (truncates).
     * @param x The decimal number to convert.
     * @return x divided by the decimal precision.
     */
    function fromDecimal(uint256 x) internal pure returns (uint256) {
        return x / DEFAULT_DECIMAL_PRECISION; // Integer division truncates
    }
}
### File: packages/contracts/common/OracleRelayerDst.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/utils/structs/EnumerableSet.sol"; // For managing assetIds if needed
import "./access/ProtocolAdminAccess.sol";
import "../interfaces/ILayerZeroEndpoint.sol";
import "../interfaces/ILayerZeroUserApplicationConfig.sol";
import "./interfaces/IOracleRelayer.sol";
import "../interfaces/ILayerZeroReceiver.sol";

/**
 * @title OracleRelayerDst
 * @author Unxversal Team
 * @notice Receives price data from a trusted LayerZero source (OracleRelayerSrc) and stores it.
 * @dev Implements IOracleRelayer for other Peaq contracts (Synth, Lend, Perps, Options) to consume prices.
 *      The owner (Admin) can manually set prices in emergencies or adjust stale tolerance.
 *      This contract is a LayerZero User Application (UA).
 */
contract OracleRelayerDst is ProtocolAdminAccess, ILayerZeroUserApplicationConfig, IOracleRelayer, ILayerZeroReceiver {
    using EnumerableSet for EnumerableSet.UintSet;

    ILayerZeroEndpoint public immutable lzEndpoint;

    uint16 public trustedSrcChainId;    // LayerZero chain ID of the source (e.g., Polygon)
    bytes public trustedSrcAppAddress; // OracleRelayerSrc address on source chain (LayerZero bytes format)

    struct PriceInfo {
        uint256 price;        // Price with implied decimals (e.g., 18 for USD value)
        uint32 lastUpdatedAt; // Unix timestamp from the original oracle source (e.g., Chainlink round)
    }
    mapping(uint256 => PriceInfo) internal _priceInfos; // assetId => PriceInfo
    EnumerableSet.UintSet private _supportedAssetIds; // To keep track of assets with configured prices

    uint32 public override staleToleranceSec;

    // Payload structure expected from OracleRelayerSrc: { assetId, price, timestamp }
    // Defined here for clarity, though only used for decoding.
    struct PriceMsg {
        uint256 assetId;
        uint256 price;
        uint32 ts;
    }

    event PriceReceivedAndStored(
        uint256 indexed assetId,
        uint256 price,
        uint32 timestamp,
        uint16 indexed srcChainId,
        bytes srcAddress
    );
    event TrustedRemoteSet(uint16 newSrcChainId, bytes newSrcAppAddress);
    event StaleToleranceSet(uint32 newStaleToleranceSec);
    event ManualPriceForced(uint256 indexed assetId, uint256 price, uint32 timestamp);
    event AssetSupported(uint256 indexed assetId, bool isSupported);


    /**
     * @param _lzEndpointAddress The address of the LayerZero Endpoint on Peaq.
     * @param _initialOwner The initial owner (multisig/DAO Timelock) of this contract.
     * @param _initialTrustedSrcChainId Initial trusted source LayerZero chain ID (e.g., Polygon's L0 ID).
     * @param _initialTrustedSrcAppAddress Initial trusted OracleRelayerSrc address on source chain (L0 bytes).
     * @param _initialStaleToleranceSec Initial stale tolerance in seconds (e.g., 3600 for 1 hour).
     */
    constructor(
        address _lzEndpointAddress,
        address _initialOwner,
        uint16 _initialTrustedSrcChainId,
        bytes memory _initialTrustedSrcAppAddress,
        uint32 _initialStaleToleranceSec
    ) ProtocolAdminAccess(_initialOwner) {
        require(_lzEndpointAddress != address(0), "ORD: Zero L0 endpoint");
        lzEndpoint = ILayerZeroEndpoint(_lzEndpointAddress);

        setTrustedRemote(_initialTrustedSrcChainId, _initialTrustedSrcAppAddress); // Emits event
        setStaleTolerance(_initialStaleToleranceSec); // Emits event
    }

    /**
     * @notice Sets the trusted remote source chain ID and application address for LayerZero messages.
     * @dev Only callable by the owner.
     * @param _newSrcChainId The LayerZero chain ID of the source network (e.g., Polygon).
     * @param _newSrcAppAddress The address of OracleRelayerSrc on the source chain, in LayerZero bytes format.
     */
    function setTrustedRemote(uint16 _newSrcChainId, bytes memory _newSrcAppAddress) public onlyOwner {
        require(_newSrcChainId != 0, "ORD: Zero srcChainId");
        require(_newSrcAppAddress.length > 0, "ORD: Empty srcAppAddress");
        trustedSrcChainId = _newSrcChainId;
        trustedSrcAppAddress = _newSrcAppAddress;
        emit TrustedRemoteSet(_newSrcChainId, _newSrcAppAddress);
    }

    /**
     * @notice Sets the duration after which a price is considered stale.
     * @dev Only callable by the owner.
     * @param _newStaleToleranceSec The new stale tolerance in seconds. Must be greater than zero.
     */
    function setStaleTolerance(uint32 _newStaleToleranceSec) public onlyOwner {
        require(_newStaleToleranceSec > 0, "ORD: Stale tolerance must be > 0");
        staleToleranceSec = _newStaleToleranceSec;
        emit StaleToleranceSet(_newStaleToleranceSec);
    }

    /**
     * @notice Internal handler for LayerZero messages. Called by `lzReceive`.
     * @dev Verifies the source and stores the received price data.
     * @param _srcChainId The source chain ID of the message.
     * @param _srcAddress The source application address of the message.
     * @param _payload The price data payload.
     */
    function _handleLzMessage(
        uint16 _srcChainId,
        bytes calldata _srcAddress,
        // uint64 _nonce, // Nonce is available from lzReceive if needed
        bytes calldata _payload
    ) internal {
        require(_srcChainId == trustedSrcChainId, "ORD: Invalid source chain");
        require(
            keccak256(_srcAddress) == keccak256(trustedSrcAppAddress),
            "ORD: Invalid source address"
        );

        PriceMsg memory decodedMsg = abi.decode(_payload, (PriceMsg));
        require(decodedMsg.price > 0, "ORD: Decoded price is zero");
        require(decodedMsg.ts > 0 && decodedMsg.ts <= block.timestamp, "ORD: Invalid decoded timestamp");


        _priceInfos[decodedMsg.assetId] = PriceInfo({
            price: decodedMsg.price,
            lastUpdatedAt: decodedMsg.ts
        });

        if (!_supportedAssetIds.contains(decodedMsg.assetId)) {
            _supportedAssetIds.add(decodedMsg.assetId);
            emit AssetSupported(decodedMsg.assetId, true);
        }

        emit PriceReceivedAndStored(
            decodedMsg.assetId,
            decodedMsg.price,
            decodedMsg.ts,
            _srcChainId,
            _srcAddress
        );
    }

    /**
     * @notice Owner can manually set/update a price for an asset.
     * @dev Use cautiously, e.g., for assets not relayed via L0 or in emergencies.
     *      The timestamp should be the current block.timestamp or a recent, verifiable time.
     * @param assetId The assetId to update.
     * @param price The price to set (with appropriate decimals).
     * @param timestamp The timestamp to associate with this manual update.
     */
    function forcePrice(uint256 assetId, uint256 price, uint32 timestamp) external onlyOwner {
        require(price > 0, "ORD: Forced price is zero");
        require(timestamp > 0 && timestamp <= block.timestamp, "ORD: Invalid forced timestamp");

        _priceInfos[assetId] = PriceInfo({
            price: price,
            lastUpdatedAt: timestamp
        });

        if (!_supportedAssetIds.contains(assetId)) {
            _supportedAssetIds.add(assetId);
            emit AssetSupported(assetId, true);
        }
        emit ManualPriceForced(assetId, price, timestamp);
    }

    /**
     * @notice Allows the owner to explicitly mark an assetId as supported or unsupported
     *         for price queries, independent of whether a price has been received.
     * @dev Useful for pre-configuring assets or disabling a problematic one.
     * @param assetId The assetId to configure.
     * @param isSupported True to mark as supported, false to mark as unsupported.
     */
    function setAssetSupport(uint256 assetId, bool isSupported) external onlyOwner {
        if (isSupported) {
            _supportedAssetIds.add(assetId);
        } else {
            _supportedAssetIds.remove(assetId);
            // Consider if also clearing _priceInfos[assetId] is desired when unsupporting.
            // delete _priceInfos[assetId]; // This would make it unavailable immediately.
        }
        emit AssetSupported(assetId, isSupported);
    }


    // --- IOracleRelayer Implementation ---

    /**
     * @inheritdoc IOracleRelayer
     */
    function getPrice(uint256 assetId) external view override returns (uint256) {
        PriceInfo storage info = _priceInfos[assetId];
        require(_supportedAssetIds.contains(assetId), "ORD: Asset not supported");
        require(info.lastUpdatedAt > 0, "ORD: Price not available");
        require(block.timestamp - info.lastUpdatedAt <= staleToleranceSec, "ORD: Price is stale");
        return info.price;
    }

    /**
     * @inheritdoc IOracleRelayer
     */
    function getPriceData(uint256 assetId) external view override returns (uint256 price, uint32 lastUpdatedAt) {
        PriceInfo storage info = _priceInfos[assetId];
        require(_supportedAssetIds.contains(assetId), "ORD: Asset not supported");
        require(info.lastUpdatedAt > 0, "ORD: Price not available for asset");
        return (info.price, info.lastUpdatedAt);
    }

    /**
     * @inheritdoc IOracleRelayer
     */
    function isPriceStale(uint256 assetId) external view override returns (bool) {
        if (!_supportedAssetIds.contains(assetId)) return true; // Not supported is stale
        PriceInfo storage info = _priceInfos[assetId];
        if (info.lastUpdatedAt == 0) return true; // Not available is stale
        return (block.timestamp - info.lastUpdatedAt > staleToleranceSec);
    }

    // staleToleranceSec() is already public and part of IOracleRelayer

    // --- ILayerZeroUserApplicationConfig Implementation ---

    /**
     * @inheritdoc ILayerZeroUserApplicationConfig
     * @dev Delegates to the LayerZero Endpoint. Only callable by the owner.
     */
    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external override onlyOwner {
        lzEndpoint.setConfig(_version, _chainId, _configType, _config);
    }

    /**
     * @inheritdoc ILayerZeroUserApplicationConfig
     * @dev Delegates to the LayerZero Endpoint. Only callable by the owner.
     */
    function setSendVersion(uint16 _version) external override onlyOwner {
        lzEndpoint.setSendVersion(_version);
    }

    /**
     * @inheritdoc ILayerZeroUserApplicationConfig
     * @dev Delegates to the LayerZero Endpoint. Only callable by the owner.
     */
    function setReceiveVersion(uint16 _version) external override onlyOwner {
        lzEndpoint.setReceiveVersion(_version);
    }

    /**
     * @inheritdoc ILayerZeroReceiver
     * @dev Main LayerZero message handler. Must be called by the LayerZero Endpoint.
     */
    function lzReceive(uint16 _srcChainId, bytes calldata _srcAddress, uint64 _nonce, bytes calldata _payload) external override {
        require(msg.sender == address(lzEndpoint), "ORD: Caller is not LZ Endpoint");
        _handleLzMessage(_srcChainId, _srcAddress, _payload); // Pass nonce if _handleLzMessage uses it
    }

    /**
     * @inheritdoc ILayerZeroUserApplicationConfig
     * @dev Delegates to the LayerZero Endpoint. Only callable by the owner.
     */
    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external override onlyOwner {
        lzEndpoint.forceResumeReceive(_srcChainId, _srcAddress);
    }

    // --- View functions for supported assets ---
    function isAssetSupported(uint256 assetId) external view returns (bool) {
        return _supportedAssetIds.contains(assetId);
    }

    function getSupportedAssetIdsCount() external view returns (uint256) {
        return _supportedAssetIds.length();
    }

    function getSupportedAssetIdAtIndex(uint256 index) external view returns (uint256) {
        return _supportedAssetIds.at(index);
    }
}
### File: packages/contracts/common/interfaces/ILiquidationEngine.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title ILiquidationEngine
 * @author Unxversal Team
 * @notice Interface for contracts that handle the liquidation of undercollateralized
 *         positions or risky accounts within a DeFi protocol.
 * @dev Specific implementations will handle different types of positions (e.g., synth debt,
 *      loans, perpetual futures) and their respective liquidation mechanisms.
 */
interface ILiquidationEngine {
    /**
     * @notice Emitted when a position is successfully liquidated.
     * @param liquidator The address that initiated the liquidation.
     * @param account The address of the account/position that was liquidated.
     * @param collateralSeizedAsset The address of the collateral asset seized by the liquidator.
     * @param collateralSeizedAmount The amount of collateral asset seized.
     * @param debtRepaidAsset The address of the debt asset that was repaid.
     * @param debtRepaidAmount The amount of debt asset repaid.
     */
    event PositionLiquidated(
        address indexed liquidator,
        address indexed account,
        address collateralSeizedAsset,
        uint256 collateralSeizedAmount,
        address debtRepaidAsset,
        uint256 debtRepaidAmount
    );

    // Note: The `liquidate` function signature can vary significantly based on the protocol.
    // For example:
    // - Synth: liquidate(accountToLiquidate, synthToRepay, amountToRepayInSynth)
    // - Lend: liquidate(borrower, collateralToSeize, repayAmount, assetToRepay)
    // - Perps: liquidate(trader, marketId, portionToClose)
    //
    // It's challenging to create a single `liquidate` signature that fits all perfectly
    // without becoming overly generic or complex with structs.
    //
    // Option 1: Keep it very generic (less useful for direct type checking).
    // function liquidate(address account, bytes calldata data) external returns (bool success);
    //
    // Option 2: Define common parameters, and let implementations add specifics.
    // This is still hard because "collateral" and "debt" concepts vary.
    //
    // Option 3: Don't define a specific `liquidate` signature in this common interface.
    // Instead, let each protocol's liquidation engine (e.g., `SynthLiquidationEngine.sol`)
    // define its own `liquidate` function tailored to its needs. This common interface
    // would then primarily serve as a marker or for shared events/view functions if any.
    //
    // Given the diversity, Option 3 is often more practical. Individual liquidation contracts
    // will have their own public `liquidate` functions. This common interface can then
    // be used for common view functions or to group them conceptually.

    /**
     * @notice Checks if a given account or position is eligible for liquidation.
     * @dev The definition of "eligible" is protocol-specific (e.g., health factor < 1, CR < minCR).
     * @param account The address of the account or an identifier for the position.
     * @return isLiquidatable True if the account/position can be liquidated, false otherwise.
     */
    function isLiquidatable(address account) external view returns (bool);

    // Potentially, add other common view functions:
    // function getLiquidationPenalty(address asset) external view returns (uint256 penaltyBps);
    // function getCloseFactor(address asset) external view returns (uint256 closeFactorBps);

    // For now, `isLiquidatable` is a good common candidate.
    // The actual `liquidate` function will be specific to each protocol's engine.
}
### File: packages/contracts/common/interfaces/IAdminModule.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title IAdminModule
 * @author Unxversal Team
 * @notice Interface for administrative modules controlling protocol components.
 * @dev Defines standard functions for pausing, unpausing, and managing ownership,
 *      intended to be implemented by specific admin contracts for each protocol.
 *      The owner of implementations will typically be a multisig or DAO Timelock.
 */
interface IAdminModule {
    /**
     * @notice Emitted when the entire module or a significant part of its controlled protocol is paused.
     * @param account The account that triggered the pause (usually the owner).
     */
    event Paused(address account);

    /**
     * @notice Emitted when the entire module or a significant part of its controlled protocol is unpaused.
     * @param account The account that triggered the unpause (usually the owner).
     */
    event Unpaused(address account);

    // Note: OpenZeppelin's Ownable already emits OwnershipTransferred(address previousOwner, address newOwner)
    // So, we don't need to redefine it here unless we want a more specific event.

    /**
     * @notice Pauses the contract or the functionalities it controls.
     * @dev Implementations should ensure this can only be called by the owner.
     *      The exact scope of "pause" is implementation-specific (e.g., halt new mints,
     *      stop all trading, prevent new borrows).
     */
    function pause() external;

    /**
     * @notice Unpauses the contract or the functionalities it controls.
     * @dev Implementations should ensure this can only be called by the owner.
     */
    function unpause() external;

    /**
     * @notice Returns true if the contract or its main functionalities are paused, false otherwise.
     */
    function paused() external view returns (bool);

    /**
     * @notice Returns the address of the current owner.
     * @dev This is part of the Ownable pattern.
     */
    function owner() external view returns (address);

    /**
     * @notice Transfers ownership of the contract to a new account (`newOwner`).
     * @dev Can only be called by the current owner.
     *      This is part of the Ownable pattern.
     * @param newOwner The address of the new owner.
     */
    function transferOwnership(address newOwner) external;

    /**
     * @notice Leaves the contract without owner. It will not be possible to call
     * `onlyOwner` functions anymore.
     * @dev Can only be called by the current owner.
     *      WARNING: Renouncing ownership will leave the contract without an owner,
     *      thereby removing any functionality that is only available to the owner.
     *      This is part of the Ownable pattern and should be used with extreme caution,
     *      typically only if the contract is designed to become fully autonomous or
     *      if ownership is being transferred to a burn address or a fully decentralized DAO
     *      that doesn't use this direct ownership pattern.
     */
    function renounceOwnership() external;

    // Potential future additions:
    // - Functions for managing fee recipients if fees are collected by admin modules.
    // - Functions for upgrading target contract addresses if the admin module acts as a proxy admin.
    // - Granular pause functions (e.g., pauseMinting(), pauseBorrowing()) if needed.
}
### File: packages/contracts/common/interfaces/IOracleRelayer.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/**
 * @title IOracleRelayer
 * @notice Interface for contracts that provide oracle price data.
 * @dev This interface is implemented by OracleRelayerDst on the Peaq network.
 */
interface IOracleRelayer {
    /**
     * @notice Fetches the latest price for a given asset.
     * @dev Reverts if the price is stale (older than `staleToleranceSec`) or not available.
     * @param assetId The unique identifier for the asset.
     * @return price The price of the asset, typically in a fixed-point format (e.g., 18 decimals USD).
     */
    function getPrice(uint256 assetId) external view returns (uint256 price);

    /**
     * @notice Fetches the latest price data including its last update time.
     * @dev Reverts if the price is not available for the given assetId.
     * @dev It is the responsibility of the caller to check `lastUpdatedAt` against `staleToleranceSec`
     *      or current block.timestamp if staleness is a concern for their specific use case.
     * @param assetId The unique identifier for the asset.
     * @return price The price of the asset.
     * @return lastUpdatedAt The Unix timestamp of when the price was last updated by the oracle source (e.g., Chainlink).
     */
    function getPriceData(uint256 assetId) external view returns (uint256 price, uint32 lastUpdatedAt);

    /**
     * @notice Checks if a price for a given asset is considered stale based on the configured tolerance.
     * @param assetId The unique identifier for the asset.
     * @return isStale True if the price is stale or not available, false otherwise.
     */
    function isPriceStale(uint256 assetId) external view returns (bool);

    /**
     * @notice Retrieves the configured stale tolerance for price data.
     * @return The stale tolerance in seconds.
     */
    function staleToleranceSec() external view returns (uint32);
}
### File: packages/contracts/synth/SynthFactory.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol"; // For factory ownership
import "@openzeppelin/contracts/security/Pausable.sol";
import "./SynthToken.sol"; // The actual SynthToken implementation
import "../common/interfaces/IOracleRelayer.sol"; // For storing and validating oracle interface

/**
 * @title SynthFactory
 * @author Unxversal Team
 * @notice Factory for deploying and managing synthetic asset (sAsset) tokens.
 * @dev Deploys full instances of SynthToken (not clones, for constructor arg simplicity in V1).
 *      Manages oracle asset IDs and custom CRs for each deployed synth.
 *      Grants MINTER_ROLE and BURNER_ROLE of newly created SynthTokens to a specified controller (USDCVault).
 *      The DEFAULT_ADMIN_ROLE of newly created SynthTokens is granted to this factory,
 *      allowing it to manage roles further if needed (e.g., transfer admin to DAO).
 */
contract SynthFactory is Ownable, Pausable {
    IOracleRelayer public oracle; // Shared oracle relayer instance (OracleRelayerDst)

    struct SynthConfig {
        address tokenAddress;   // Address of the deployed sAsset ERC20
        uint256 assetId;        // ID used to fetch price from the oracle
        uint256 customMinCRbps; // Custom min CR for this synth in BPS (0 for vault default)
        bool isRegistered;
    }

    mapping(address => SynthConfig) public synthConfigsByAddress; // sAsset address => config
    mapping(uint256 => address) public synthAddressByAssetId;   // Oracle assetId => sAsset address
    address[] public deployedSynthAddresses; // Array of all deployed sAsset contract addresses

    event SynthDeployedAndConfigured(
        address indexed synthAddress,
        string name,
        string symbol,
        uint256 indexed assetId,
        uint256 customMinCRbps,
        address indexed controllerWithRoles // Typically the USDCVault
    );
    event SynthCustomMinCRSet(address indexed synthAddress, uint256 newCustomMinCRbps);
    event OracleSet(address indexed newOracleAddress);
    event SynthAdminRoleTransferred(address indexed synthAddress, address indexed newAdmin);


    /**
     * @param _initialOwner The initial owner (e.g., SynthAdmin or deployer).
     * @param _oracleAddress Address of the IOracleRelayer contract (OracleRelayerDst).
     */
    constructor(address _initialOwner, address _oracleAddress) Ownable(_initialOwner) {
        require(_oracleAddress != address(0), "SF: Zero oracle address");
        oracle = IOracleRelayer(_oracleAddress);
        emit OracleSet(_oracleAddress);
    }

    /**
     * @notice Deploys and configures a new synthetic asset (sAsset) token.
     * @dev Only callable by the contract owner (e.g., SynthAdmin).
     *      The DEFAULT_ADMIN_ROLE of the new SynthToken is this factory.
     *      MINTER_ROLE and BURNER_ROLE are granted to `controllerAddress`.
     * @param name Name for the new synth (e.g., "Unxversal Bitcoin").
     * @param symbol Symbol for the new synth (e.g., "sBTC").
     * @param assetId The oracle asset ID for the underlying. Must be unique.
     * @param customMinCRbps Custom minimum CR for this synth in BPS (e.g., 15000 for 150%). 0 to use vault default.
     * @param controllerAddress The address (typically USDCVault) to receive mint/burn roles for the new synth.
     * @return synthAddress The address of the newly deployed sAsset token.
     */
    function deploySynth(
        string calldata name,
        string calldata symbol,
        uint256 assetId,
        uint256 customMinCRbps,
        address controllerAddress
    ) external onlyOwner whenNotPaused returns (address synthAddress) {
        require(assetId != 0, "SF: Zero assetId");
        require(synthAddressByAssetId[assetId] == address(0), "SF: AssetId already registered");
        require(controllerAddress != address(0), "SF: Zero controller address");
        if (customMinCRbps > 0) { // 0 means use vault default
            require(customMinCRbps >= 10000, "SF: Custom CR must be >= 100%"); // 10000 BPS = 100%
        }

        // Deploy new SynthToken, factory becomes its initial admin
        SynthToken newSynth = new SynthToken(name, symbol, address(this));
        synthAddress = address(newSynth);

        // Grant Minter and Burner roles to the controller (USDCVault)
        newSynth.grantRole(SynthToken.MINTER_ROLE, controllerAddress);
        newSynth.grantRole(SynthToken.BURNER_ROLE, controllerAddress);

        // Store configuration
        synthConfigsByAddress[synthAddress] = SynthConfig({
            tokenAddress: synthAddress,
            assetId: assetId,
            customMinCRbps: customMinCRbps,
            isRegistered: true
        });
        synthAddressByAssetId[assetId] = synthAddress;
        deployedSynthAddresses.push(synthAddress);

        emit SynthDeployedAndConfigured(
            synthAddress, name, symbol, assetId, customMinCRbps, controllerAddress
        );
        return synthAddress;
    }

    /**
     * @notice Updates the custom minimum CR for an existing synth.
     * @param synthAddress The address of the sAsset token.
     * @param newCustomMinCRbps The new custom CR in BPS. 0 to use vault default.
     */
    function setSynthCustomMinCR(address synthAddress, uint256 newCustomMinCRbps) external onlyOwner {
        SynthConfig storage config = synthConfigsByAddress[synthAddress];
        require(config.isRegistered, "SF: Synth not registered");
        if (newCustomMinCRbps > 0) {
            require(newCustomMinCRbps >= 10000, "SF: Custom CR must be >= 100%");
        }
        config.customMinCRbps = newCustomMinCRbps;
        emit SynthCustomMinCRSet(synthAddress, newCustomMinCRbps);
    }

    /**
     * @notice Updates the oracle address used by this factory (and potentially by associated contracts).
     * @param _newOracleAddress The address of the IOracleRelayer implementation.
     */
    function setOracle(address _newOracleAddress) external onlyOwner {
        require(_newOracleAddress != address(0), "SF: Zero oracle address");
        oracle = IOracleRelayer(_newOracleAddress);
        emit OracleSet(_newOracleAddress);
    }

    /**
     * @notice Transfers the DEFAULT_ADMIN_ROLE of a deployed SynthToken to a new admin.
     * @dev Useful for transferring admin rights from the factory to a DAO or multisig.
     *      Only callable by the owner of this factory.
     * @param synthAddress The address of the sAsset token.
     * @param newAdmin The address of the new admin for the SynthToken.
     */
    function transferSynthTokenAdmin(address synthAddress, address newAdmin) external onlyOwner {
        SynthConfig storage config = synthConfigsByAddress[synthAddress];
        require(config.isRegistered, "SF: Synth not registered");
        require(newAdmin != address(0), "SF: New admin is zero address");

        SynthToken(synthAddress).grantRole(SynthToken.DEFAULT_ADMIN_ROLE, newAdmin);
        SynthToken(synthAddress).renounceRole(SynthToken.DEFAULT_ADMIN_ROLE, address(this));
        emit SynthAdminRoleTransferred(synthAddress, newAdmin);
    }


    // --- View Functions ---
    function getSynthConfig(address synthAddress) external view returns (SynthConfig memory) {
        require(synthConfigsByAddress[synthAddress].isRegistered, "SF: Synth not registered");
        return synthConfigsByAddress[synthAddress];
    }

    function getSynthAddressByAssetId(uint256 assetId) external view returns (address) {
        return synthAddressByAssetId[assetId];
    }

    function getDeployedSynthsCount() external view returns (uint256) {
        return deployedSynthAddresses.length;
    }

    function getDeployedSynthAddressAtIndex(uint256 index) external view returns (address) {
        return deployedSynthAddresses[index];
    }

    function isSynthRegistered(address queryAddress) external view returns (bool) {
        return synthConfigsByAddress[queryAddress].isRegistered;
    }

    // --- Pausable ---
    function pause() external onlyOwner { // Pauses deploying new synths
        _pause();
    }

    function unpause() external onlyOwner {
        _unpause();
    }
}
### File: packages/contracts/synth/USDCVault.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol"; // For admin functions directly on vault
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

import "../common/interfaces/IOracleRelayer.sol";
import "./interfaces/ISynthToken.sol";
import "./SynthFactory.sol"; // To get synth info like assetId and customMinCR

// Using ProtocolAdminAccess if admin functions are primarily delegated,
// or Ownable if this vault manages its own params via its owner.
// Let's assume some parameters are directly Ownable by SynthAdmin for now.
// Or, this contract is Ownable by SynthAdmin.

/**
 * @title USDCVault
 * @author Unxversal Team
 * @notice Manages USDC collateral, minting/burning of sAssets, and user positions.
 * @dev Users deposit USDC to mint sAssets. Positions are subject to liquidation if CR falls.
 *      Fees are collected on mint/burn. Tracks USD value of minted sAssets at time of minting.
 */
contract USDCVault is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    // --- Constants ---
    uint8 public constant USDC_DECIMALS = 6; // Standard USDC decimals
    uint256 public constant PRICE_PRECISION = 1e18; // Oracle prices and internal USD values
    uint256 public constant S_ASSET_DECIMALS_NORMALIZER = 1e12; // To normalize 18-dec sAsset to 6-dec for USD value if needed, or use 1e18 / 10^sAssetDecimals
    uint256 public constant BPS_DENOMINATOR = 10000;
    uint256 public constant CR_DENOMINATOR = 10000; // For CR in BPS, e.g., 15000 = 150%

    // --- Modifiers ---
    modifier onlyLiquidationEngine() {
        require(msg.sender == liquidationEngine, "Vault: Caller not Liquidation Engine");
        _;
    }

    // --- Configuration ---
    IERC20 public immutable usdcToken;
    IOracleRelayer public oracle;
    SynthFactory public synthFactory; // To query synth details like assetId, customMinCR
    address public liquidationEngine; // Address of the SynthLiquidationEngine
    address public feeRecipient;      // Receives mint/burn fees
    address public treasuryAddress;   // Receives surplus from buffer

    uint256 public minCollateralRatioBps; // Default min CR if no per-synth customCR, e.g., 15000 (150%)
    uint256 public mintFeeBps;            // Fee for minting sAssets, e.g., 50 (0.5%)
    uint256 public burnFeeBps;            // Fee for burning sAssets, e.g., 50 (0.5%)
    uint256 public surplusBufferThreshold; // If surplus exceeds this, can be swept to treasury
    uint256 public currentSurplusBuffer;   // USDC accumulated from fees/liquidations beyond covering debt

    // --- User Position Storage ---
    struct SynthPositionData {
        uint256 amountMinted;        // Total quantity of this sAsset minted by the user
        uint256 totalUsdValueAtMint; // Aggregate USD value of `amountMinted` at the time(s) of minting
    }

    struct UserPosition {
        uint256 usdcCollateral; // Total USDC deposited by the user
        mapping(address => SynthPositionData) synthSpecifics; // sAssetAddress => SynthPositionData
    }
    mapping(address => UserPosition) public positions; // userAddress => UserPosition

    // --- Events ---
    event CollateralDeposited(address indexed user, uint256 amountUsdc);
    event CollateralWithdrawn(address indexed user, uint256 amountUsdc);
    event SynthMinted(
        address indexed user, address indexed synthAddress, uint256 assetId,
        uint256 amountSynthMinted, uint256 usdValueMinted, uint256 usdcCollateralizedForMint, uint256 feePaid
    );
    event SynthBurned(
        address indexed user, address indexed synthAddress, uint256 assetId,
        uint256 amountSynthBurned, uint256 usdValueRepaid, uint256 usdcReturned, uint256 feePaid
    );
    event PositionHealthUpdated(address indexed user, uint256 newCollateralRatioBps); // After an operation
    event SurplusSweptToTreasury(uint256 amountSwpt);
    // Admin parameter change events
    event MinCollateralRatioSet(uint256 newMinCRbps);
    event MintFeeSet(uint256 newFeeBps);
    event BurnFeeSet(uint256 newFeeBps);
    event FeeRecipientSet(address newRecipient);
    event TreasurySet(address newTreasury);
    event LiquidationEngineSet(address newEngine);
    event OracleSet(address newOracle);
    event SynthFactorySet(address newFactory);
    event SurplusBufferThresholdSet(uint256 newThreshold);


    constructor(
        address _usdcTokenAddress,
        address _oracleAddress,
        address _synthFactoryAddress,
        address _initialOwner
    ) Ownable(_initialOwner) {
        require(_usdcTokenAddress != address(0), "Vault: Zero USDC address");
        // require(IERC20(_usdcTokenAddress).decimals() == USDC_DECIMALS, "Vault: Incorrect USDC decimals"); // Can't call view on uninitialized contract in constructor
        usdcToken = IERC20(_usdcTokenAddress);
        setOracle(_oracleAddress); // Emits event
        setSynthFactory(_synthFactoryAddress); // Emits event
        // Other params like fees, minCR, recipients are set by owner post-deployment
    }

    // --- Admin Functions (Ownable) ---
    function setMinCollateralRatio(uint256 _newMinCRbps) external onlyOwner {
        require(_newMinCRbps >= CR_DENOMINATOR, "Vault: Min CR too low"); // Must be >= 100%
        minCollateralRatioBps = _newMinCRbps;
        emit MinCollateralRatioSet(_newMinCRbps);
    }
    function setMintFee(uint256 _newFeeBps) external onlyOwner {
        require(_newFeeBps <= 1000, "Vault: Mint fee too high"); // Max 10% example
        mintFeeBps = _newFeeBps;
        emit MintFeeSet(_newFeeBps);
    }
    function setBurnFee(uint256 _newFeeBps) external onlyOwner {
        require(_newFeeBps <= 1000, "Vault: Burn fee too high");
        burnFeeBps = _newFeeBps;
        emit BurnFeeSet(_newFeeBps);
    }
    function setFeeRecipient(address _newRecipient) external onlyOwner {
        require(_newRecipient != address(0), "Vault: Zero fee recipient");
        feeRecipient = _newRecipient;
        emit FeeRecipientSet(_newRecipient);
    }
    function setTreasury(address _newTreasury) external onlyOwner {
        require(_newTreasury != address(0), "Vault: Zero treasury");
        treasuryAddress = _newTreasury;
        emit TreasurySet(_newTreasury);
    }
    function setLiquidationEngine(address _newEngine) external onlyOwner {
        require(_newEngine != address(0), "Vault: Zero liquidation engine");
        liquidationEngine = _newEngine;
        emit LiquidationEngineSet(_newEngine);
    }
    function setOracle(address _newOracle) external onlyOwner {
        require(_newOracle != address(0), "Vault: Zero oracle");
        oracle = IOracleRelayer(_newOracle);
        emit OracleSet(_newOracle);
    }
    function setSynthFactory(address _newFactory) external onlyOwner {
        require(_newFactory != address(0), "Vault: Zero factory");
        synthFactory = SynthFactory(_newFactory);
        emit SynthFactorySet(_newFactory);
    }
    function setSurplusBufferThreshold(uint256 _newThreshold) external onlyOwner {
        surplusBufferThreshold = _newThreshold;
        emit SurplusBufferThresholdSet(_newThreshold);
    }
    function pauseActions() external onlyOwner { _pause(); }
    function unpauseActions() external onlyOwner { _unpause(); }

    // --- User Functions ---

    /** @notice User deposits USDC into their collateral balance. */
    function depositCollateral(uint256 amountUsdc) external nonReentrant whenNotPaused {
        require(amountUsdc > 0, "Vault: Zero deposit amount");
        usdcToken.safeTransferFrom(_msgSender(), address(this), amountUsdc);
        positions[_msgSender()].usdcCollateral += amountUsdc;
        emit CollateralDeposited(_msgSender(), amountUsdc);
        // Optionally, update health factor if they have existing debt
        _updateAndEmitHealth(_msgSender());
    }

    /** @notice User withdraws available USDC collateral. */
    function withdrawCollateral(uint256 amountUsdc) external nonReentrant whenNotPaused {
        require(amountUsdc > 0, "Vault: Zero withdrawal amount");
        UserPosition storage userPos = positions[_msgSender()];
        require(userPos.usdcCollateral >= amountUsdc, "Vault: Insufficient collateral balance");

        // Calculate total USD value of all minted synths for this user
        uint256 totalMintedUsdValue = _getTotalMintedUsdValue(_msgSender());
        
        // Calculate remaining collateral and check CR
        uint256 remainingCollateral = userPos.usdcCollateral - amountUsdc;
        if (totalMintedUsdValue > 0) { // Only check CR if there's outstanding debt
            uint256 effectiveMinCR = minCollateralRatioBps; // Default, can be overridden per synth, but this is for overall position
            // This check is simplified for overall health. A per-synth CR check upon withdrawal would be more complex.
            // For now, check against the general minCollateralRatioBps for the *total* debt.
            uint256 currentTotalDebtValue = _getCurrentTotalDebtUsdValue(_msgSender());
            require(currentTotalDebtValue == 0 || (remainingCollateral * CR_DENOMINATOR / currentTotalDebtValue) >= effectiveMinCR,
                "Vault: Withdrawal would make position undercollateralized");
        }
        // else, if no debt, they can withdraw all collateral.

        userPos.usdcCollateral = remainingCollateral;
        usdcToken.safeTransfer(_msgSender(), amountUsdc);
        emit CollateralWithdrawn(_msgSender(), amountUsdc);
        if (totalMintedUsdValue > 0) _updateAndEmitHealth(_msgSender());
    }

    /**
     * @notice User mints sAssets against their deposited USDC.
     * @param synthAddress The address of the sAsset token to mint.
     * @param amountSynthToMint The quantity of sAsset to mint (in sAsset's native decimals, e.g., 1e18 for 1 sBTC).
     */
    function mintSynth(address synthAddress, uint256 amountSynthToMint) external nonReentrant whenNotPaused {
        require(synthFactory.isSynthRegistered(synthAddress), "Vault: Synth not registered");
        require(amountSynthToMint > 0, "Vault: Zero mint amount");
        require(feeRecipient != address(0), "Vault: Fee recipient not set");


        UserPosition storage userPos = positions[_msgSender()];
        SynthFactory.SynthConfig memory synthConfig = synthFactory.getSynthConfig(synthAddress);
        uint256 sAssetDecimals = ISynthToken(synthAddress).decimals(); // Assumes sAssets have decimals()

        // Get current price of the sAsset's underlying in USD (1e18 precision)
        uint256 currentPriceUsd = oracle.getPrice(synthConfig.assetId); // Reverts if stale/unavailable

        // Calculate USD value of the sAsset to be minted
        // (amount * price) / 10^sAssetDecimals (to get USD value with PRICE_PRECISION)
        uint256 usdValueToMint = Math.mulDiv(amountSynthToMint, currentPriceUsd, (10**sAssetDecimals));

        // Calculate mint fee
        uint256 feeUsd = (usdValueToMint * mintFeeBps) / BPS_DENOMINATOR;
        uint256 usdValueToMintNetOfFee = usdValueToMint - feeUsd; // This is the value added to debt tracking

        // Determine effective Min CR
        uint256 effectiveMinCRbps = synthConfig.customMinCRbps > 0 ? synthConfig.customMinCRbps : minCollateralRatioBps;
        require(effectiveMinCRbps > 0, "Vault: MinCR not set");

        // Calculate total current USD value of ALL outstanding sAssets for this user AFTER this mint
        uint256 newTotalDebtUsdValue = _getCurrentTotalDebtUsdValue(_msgSender()) + usdValueToMintNetOfFee;
        
        // Check overall position health
        require(newTotalDebtUsdValue == 0 || (userPos.usdcCollateral * CR_DENOMINATOR / newTotalDebtUsdValue) >= effectiveMinCRbps,
            "Vault: Insufficient collateral for new CR");

        // Update user's position
        userPos.synthSpecifics[synthAddress].amountMinted += amountSynthToMint;
        userPos.synthSpecifics[synthAddress].totalUsdValueAtMint += usdValueToMintNetOfFee; // Track net USD value added to debt

        // Collect fee in USDC by deducting from user's collateral (or user pre-pays)
        // For simplicity, assume fee is effectively part of the collateralization requirement
        // Or, more directly, reduce collateral by fee amount IF user has enough *excess* collateral.
        // The spec implies fee is from the value minted. If mintFee is 0.5% on $100 mint, user gets $99.5 sAsset value
        // or user needs to collateralize $100 value + fee value.
        // Let's assume fee reduces the sAsset value for debt tracking (as done with usdValueToMintNetOfFee).
        // The fee itself needs to be transferred to feeRecipient.
        // The simplest way is to ensure user has enough collateral to cover `usdValueToMint` for CR purposes,
        // and then fee is taken from the transaction flow or from their collateral.
        // If fee is paid from collateral:
        require(userPos.usdcCollateral >= feeUsd, "Vault: Insufficient collateral for fee"); // This is complex if collateral is tight
        // A common way: user deposits USDC. Mint operation implies a cost.
        // The `usdValueToMint` (gross) determines collateral needed. Fee is separate.
        // Let's say fee is taken from the user's collateral pool.
        if (feeUsd > 0) {
            require(userPos.usdcCollateral >= feeUsd, "Vault: Insufficient collateral for mint fee");
            userPos.usdcCollateral -= feeUsd;
            usdcToken.safeTransfer(feeRecipient, feeUsd); // This contract transfers its USDC
        }

        // Mint the sAsset tokens
        ISynthToken(synthAddress).mint(_msgSender(), amountSynthToMint);

        emit SynthMinted(
            _msgSender(), synthAddress, synthConfig.assetId, amountSynthToMint,
            usdValueToMintNetOfFee, /* collateralizedForMint - this is complex */ 0, feeUsd
        );
        _updateAndEmitHealth(_msgSender());
    }

    /**
     * @notice User burns sAssets to reclaim a portion of their USDC collateral.
     * @param synthAddress The address of the sAsset token to burn.
     * @param amountSynthToBurn The quantity of sAsset to burn.
     */
    function burnSynth(address synthAddress, uint256 amountSynthToBurn) external nonReentrant whenNotPaused {
        require(synthFactory.isSynthRegistered(synthAddress), "Vault: Synth not registered");
        require(amountSynthToBurn > 0, "Vault: Zero burn amount");
        require(feeRecipient != address(0), "Vault: Fee recipient not set");

        UserPosition storage userPos = positions[_msgSender()];
        SynthPositionData storage synthPosData = userPos.synthSpecifics[synthAddress];
        SynthFactory.SynthConfig memory synthConfig = synthFactory.getSynthConfig(synthAddress);
         uint256 sAssetDecimals = ISynthToken(synthAddress).decimals();

        require(synthPosData.amountMinted >= amountSynthToBurn, "Vault: Insufficient sAsset balance to burn");

        // Calculate USD value of the debt portion being repaid (based on average value at mint)
        uint256 usdValueToRepay;
        if (synthPosData.amountMinted > 0) { // Avoid div by zero if amountMinted was somehow 0
             usdValueToRepay = Math.mulDiv(
                amountSynthToBurn,
                synthPosData.totalUsdValueAtMint,
                synthPosData.amountMinted
            );
        } else { // Should not happen if amountSynthToBurn > 0 and amountMinted >= amountSynthToBurn
            revert("Vault: Inconsistent synth position state");
        }
       
        // Calculate burn fee on the USD value being repaid
        uint256 feeUsd = (usdValueToRepay * burnFeeBps) / BPS_DENOMINATOR;
        uint256 usdcToReturnToUser = usdValueToRepay - feeUsd;

        // Ensure user has enough collateral to cover what's being returned + fee
        // This means usdcToReturnToUser + feeUsd (which is usdValueToRepay) must be <= userPos.usdcCollateral related to this debt.
        // This check is implicit: we deduct from totalUsdcCollateral later.

        // Check CR of REMAINING position (if any)
        uint256 remainingMintedAmount = synthPosData.amountMinted - amountSynthToBurn;
        if (remainingMintedAmount > 0) {
            uint256 remainingUsdValueAtMint = synthPosData.totalUsdValueAtMint - usdValueToRepay;
            uint256 remainingTotalCollateral = userPos.usdcCollateral - usdcToReturnToUser - feeUsd; // Collateral after this burn
            
            // Calculate current USD value of ALL remaining minted sAssets (not just this one)
            uint256 tempTotalDebtUsdValue = _getCurrentTotalDebtUsdValueExcludingSynthPortion(
                _msgSender(), synthAddress, amountSynthToBurn, usdValueToRepay
            );

            if (tempTotalDebtUsdValue > 0) { // If there's other debt or remaining debt of this synth
                uint256 effectiveMinCRbps = synthConfig.customMinCRbps > 0 ? synthConfig.customMinCRbps : minCollateralRatioBps;
                require(effectiveMinCRbps > 0, "Vault: MinCR not set for CR check");
                require(
                    (remainingTotalCollateral * CR_DENOMINATOR / tempTotalDebtUsdValue) >= effectiveMinCRbps,
                    "Vault: Burn leaves position undercollateralized"
                );
            }
        }
        // If remainingMintedAmount is 0 for this synth, and no other synths, they can withdraw all collateral associated with this burn.

        // User must approve this Vault contract to burn their sAssets
        ISynthToken(synthAddress).burnFrom(_msgSender(), amountSynthToBurn);

        // Update position state
        synthPosData.amountMinted -= amountSynthToBurn;
        synthPosData.totalUsdValueAtMint -= usdValueToRepay;
        userPos.usdcCollateral -= (usdcToReturnToUser + feeUsd); // Deduct returned amount and fee

        // Transfer USDC to user and feeRecipient
        if (feeUsd > 0) {
            usdcToken.safeTransfer(feeRecipient, feeUsd); // This contract transfers its USDC
        }
        if (usdcToReturnToUser > 0) {
            usdcToken.safeTransfer(_msgSender(), usdcToReturnToUser);
        }
        
        // Clean up map entry if all of this synth is burned and value is zero
        if (synthPosData.amountMinted == 0 && synthPosData.totalUsdValueAtMint == 0) {
            delete userPos.synthSpecifics[synthAddress];
        }


        emit SynthBurned(
            _msgSender(), synthAddress, synthConfig.assetId, amountSynthToBurn,
            usdValueToRepay, usdcToReturnToUser, feeUsd
        );
        _updateAndEmitHealth(_msgSender());
    }


    // --- Liquidation Support ---
    /**
     * @notice Called by the LiquidationEngine to liquidate a user's undercollateralized position.
     * @dev This function should only be callable by the authorized LiquidationEngine.
     *      It handles reducing user's debt and collateral, and transferring assets.
     * @param user The address of the user whose position is being liquidated.
     * @param synthToRepayAddress The sAsset being repaid by the liquidator.
     * @param amountSynthToRepay The amount of sAsset the liquidator is repaying.
     * @param collateralToSeizeAmountUsdc The amount of USDC collateral to be seized by the liquidator.
     *                                   This includes their repayment value + liquidation bonus.
     */
    function processLiquidation(
        address user,
        address synthToRepayAddress,
        uint256 amountSynthToRepay,
        uint256 collateralToSeizeAmountUsdc // Amount of USDC liquidator gets
    ) external nonReentrant whenNotPaused {
        require(msg.sender == liquidationEngine, "Vault: Caller not liquidation engine");
        require(synthFactory.isSynthRegistered(synthToRepayAddress), "Vault: Synth not registered for liquidation");

        UserPosition storage userPos = positions[user];
        SynthPositionData storage synthPosData = userPos.synthSpecifics[synthToRepayAddress];
        SynthFactory.SynthConfig memory synthConfig = synthFactory.getSynthConfig(synthToRepayAddress);

        require(synthPosData.amountMinted >= amountSynthToRepay, "Vault: Liq. repay > minted");
        require(userPos.usdcCollateral >= collateralToSeizeAmountUsdc, "Vault: Liq. seize > collateral");

        // Calculate USD value of the debt portion being repaid by liquidator
        // (based on average value at mint for the user's position)
        uint256 usdValueRepaidByLiquidator;
        if (synthPosData.amountMinted > 0) {
             usdValueRepaidByLiquidator = Math.mulDiv(
                amountSynthToRepay,
                synthPosData.totalUsdValueAtMint,
                synthPosData.amountMinted
            );
        } else {
            revert("Vault: Liq. inconsistent synth position");
        }

        // Update user's position: reduce debt, reduce collateral
        synthPosData.amountMinted -= amountSynthToRepay;
        synthPosData.totalUsdValueAtMint -= usdValueRepaidByLiquidator;
        userPos.usdcCollateral -= collateralToSeizeAmountUsdc;

        // The liquidator is assumed to have already burned the sAssets or provided them.
        // The LiquidationEngine should handle the burning of `amountSynthToRepay` from the liquidator
        // or from the user's balance if that's the model.
        // If liquidator provides sAssets to burn:
        // ISynthToken(synthToRepayAddress).burnFrom(liquidator, amountSynthToRepay);
        // For now, assume LiquidationEngine ensures sAssets are burned from somewhere.
        // This vault's role is to update the *debt* and *collateral* records.

        // Calculate if there's a profit for the system from this liquidation
        // (collateralSeized - usdValueOfDebtRepaidByLiquidator - bonusToLiquidator = systemProfit)
        // The `collateralToSeizeAmountUsdc` is what liquidator receives.
        // The system profit/loss is related to the difference between the actual value of collateral taken
        // from the user and the USD value of debt cleared for the user.
        // If `collateralToSeizeAmountUsdc` is simply what the user loses from their collateral balance,
        // and a portion of this goes to the liquidator and a portion to surplus buffer.
        // This means the `LiquidationEngine` determines the split. `USDCVault` just releases collateral.

        // For now, `USDCVault` simply releases `collateralToSeizeAmountUsdc`.
        // The `LiquidationEngine` will decide how much of this goes to the liquidator
        // and how much to the surplus buffer. This call might better be:
        // `releaseCollateralForLiquidation(user, amount)` and `decreaseDebtForLiquidation(user, synth, amountSynth, usdValue)`.
        // This `processLiquidation` function is a high-level one.

        // Transfer seized collateral (part to liquidator, part to surplus buffer)
        // This logic is typically in LiquidationEngine. Here, we just update the user's balance.
        // The LiquidationEngine will receive the `collateralToSeizeAmountUsdc` from this vault
        // (or rather, this vault transfers it out as directed by LiquidationEngine).

        // Let's assume LiquidationEngine tells us how much to send to liquidator and how much to surplus.
        // For now, this function assumes `collateralToSeizeAmountUsdc` is what the user loses.
        // The actual transfer logic needs to be coordinated with LiquidationEngine.

        // To simplify `USDCVault`: it reduces user's collateral by `collateralToSeizeAmountUsdc`.
        // The `LiquidationEngine` will then claim this amount (or parts of it).
        // This means `USDCVault` might need a function like `claimSeizedCollateral(amount)` callable by LE.
        // Or this function transfers it directly.

        // TODO: Refine interaction with LiquidationEngine for fund flow.
        // For now: User's collateral is reduced. The sAssets are considered repaid.
        // The actual movement of USDC from this vault to liquidator/surplus is TBD by LE's design.

        if (synthPosData.amountMinted == 0 && synthPosData.totalUsdValueAtMint == 0) {
            delete userPos.synthSpecifics[synthToRepayAddress];
        }

        _updateAndEmitHealth(user);
        // LiquidationEngine will emit its own detailed event.
    }


    // --- Surplus Buffer Management ---
    function sweepSurplusToTreasury() external nonReentrant onlyOwner {
        require(treasuryAddress != address(0), "Vault: Treasury not set");
        if (currentSurplusBuffer > surplusBufferThreshold) {
            uint256 amountToSweep = currentSurplusBuffer - surplusBufferThreshold;
            if (amountToSweep > 0) {
                currentSurplusBuffer -= amountToSweep;
                usdcToken.safeTransfer(treasuryAddress, amountToSweep); // This contract transfers its USDC
                emit SurplusSweptToTreasury(amountToSweep);
            }
        }
    }

    /** @dev Adds funds to the surplus buffer. Can be called by LiquidationEngine or when fees are processed. */
    function addCollateralToSurplusBuffer(uint256 amountUsdc) external whenNotPaused {
        // Restrict who can call this, e.g., LiquidationEngine or Fee collection mechanism
        // For now, let's assume fee collection part of mint/burn directly sends to feeRecipient,
        // and LiquidationEngine might send profit here.
        require(msg.sender == liquidationEngine || msg.sender == feeRecipient /*or this contract for internal fee processing*/,
                "Vault: Unauthorized surplus deposit");
        currentSurplusBuffer += amountUsdc;
        // No direct transfer needed if this function is called by an entity that already
        // caused USDC to be in this contract (e.g., if fees were paid to address(this)).
    }


    // --- View Functions ---
    function getCollateralizationRatio(address user) public view returns (uint256 crBps) {
        UserPosition storage userPos = positions[user];
        if (userPos.usdcCollateral == 0) return type(uint256).max; // Infinite CR if no debt and no collateral, or 0 if debt

        uint256 totalDebtUsd = _getCurrentTotalDebtUsdValue(user);
        if (totalDebtUsd == 0) return type(uint256).max; // Infinite CR if no debt

        // CR = (Collateral USD / Debt USD) * CR_DENOMINATOR
        // USDC collateral is already in USD (assuming 1 USDC = $1) but needs decimal adjustment
        uint256 collateralUsdValue = userPos.usdcCollateral * (PRICE_PRECISION / (10**USDC_DECIMALS));
        return Math.mulDiv(collateralUsdValue, CR_DENOMINATOR, totalDebtUsd);
    }

    function isPositionLiquidatable(address user) public view returns (bool) {
        uint256 currentCRbps = getCollateralizationRatio(user);
        // This needs to consider per-synth custom MinCR if any synth is driving the liquidation risk.
        // A simple check against global minCR:
        if (minCollateralRatioBps == 0) return false; // Not configured
        if (currentCRbps < minCollateralRatioBps) {
            return true;
        }
        // More advanced: iterate synths, check against effectiveMinCR for each portion of debt.
        // For now, global check based on average values.
        // The actual minCR for liquidation would be determined by the synth with the highest requirement
        // relative to its proportion of the debt, or simply the lowest customMinCR / global minCR.
        // Let's assume LiquidationEngine does more detailed checks.
        // This function gives a general idea.

        // A position is liquidatable if its CR is below the *effective* min CR.
        // The effective min CR might be the highest min CR of any minted synth, or the vault default.
        // For now, use vault default for this view. LiquidationEngine will be more precise.
        return currentCRbps < minCollateralRatioBps && minCollateralRatioBps > 0;
    }

    // --- Internal Helper Functions ---
    function _getTotalMintedUsdValue(address user) internal view returns (uint256 totalUsdValue) {
        // This is the sum of `totalUsdValueAtMint` across all sAssets for the user.
        // Iterating a mapping is not possible on-chain directly in Solidity.
        // This function would require off-chain computation or storing a running total for the user.
        // For on-chain CR checks during operations, we calculate it based on known synth involved.
        // For a generic view, this is problematic.
        // Let's assume this is the "book value" of their total debt.
        // For calculating current CR, we need current value of minted synths.

        // This function is actually not needed if we always calculate current debt value.
        // The important value is `_getCurrentTotalDebtUsdValue`.
        revert("Vault: _getTotalMintedUsdValue deprecated, use _getCurrentTotalDebtUsdValue");
    }

    function _getCurrentTotalDebtUsdValue(address user) internal view returns (uint256 totalCurrentUsdValue) {
        UserPosition storage userPos = positions[user];
        // This requires iterating userPos.synthSpecifics, which is a mapping.
        // This cannot be done directly in a view function if we don't know which synths user has.
        // This function is critical for CR calculation.
        // Options:
        // 1. User passes array of their minted synth addresses.
        // 2. Store an array of minted synth addresses per user (gas heavy for storage).
        // 3. Off-chain calculates this; on-chain operations recalculate for specific synth.

        // For on-chain operations like mint/burn/withdraw, we work with specific synths
        // or the full list if provided. For a general view function, this is tough.
        // Let's assume this helper is called INTERNALLY where the list of synths is enumerable
        // or we are calculating it iteratively.
        
        // This function is primarily for on-chain logic that needs the *current* value.
        // It would be called by iterating over a known set of user's synths or for a specific synth.
        // The public `getCollateralizationRatio` will need a way to get this.
        // For now, let this be a placeholder for the concept.
        // The actual CR calculation in mint/burn will be more direct for the involved synths.
        
        // This function is complex to implement generically on-chain.
        // It's better if CR checks are done in context of operations.
        // I will remove this generic helper and embed logic in mint/burn/withdraw.
        revert("Vault: _getCurrentTotalDebtUsdValue needs context of synths");
        return 0;
    }

    function _getCurrentTotalDebtUsdValueForHealthCheck(address user) internal view returns (uint256 totalCurrentUsdValue_) {
        // This would require knowing all synths a user has minted.
        // For a simplified health check emit, this is hard.
        // The LiquidationEngine will need to iterate or be provided this by liquidator.
        // For emitting health, we might only be able to do it accurately after an op involving one synth.
        // This is a known challenge in CDP systems without on-chain iteration of all debts.
        // For `_updateAndEmitHealth`, we might pass the latest CR if easily calculable.
        UserPosition storage userPos = positions[user];
        uint256 cumulativeDebt = 0;
        // This loop is illustrative, cannot iterate mapping keys directly.
        // Would need to iterate `deployedSynthAddresses` from factory and check if user has position.
        for (uint i = 0; i < synthFactory.getDeployedSynthsCount(); i++) {
            address synthAddr = synthFactory.getDeployedSynthAddressAtIndex(i);
            if (userPos.synthSpecifics[synthAddr].amountMinted > 0) {
                SynthFactory.SynthConfig memory synthConf = synthFactory.getSynthConfig(synthAddr);
                 uint256 sAssetDecimals = ISynthToken(synthAddr).decimals();
                uint256 price = oracle.getPrice(synthConf.assetId); // Assumes price is available
                cumulativeDebt += Math.mulDiv(
                    userPos.synthSpecifics[synthAddr].amountMinted, price, (10**sAssetDecimals)
                );
            }
        }
        return cumulativeDebt;
    }


    function _updateAndEmitHealth(address user) internal {
        uint256 totalDebt = _getCurrentTotalDebtUsdValueForHealthCheck(user);
        if (totalDebt == 0) {
            emit PositionHealthUpdated(user, type(uint256).max);
        } else {
            uint256 collateralUsdValue = positions[user].usdcCollateral * (PRICE_PRECISION / (10**USDC_DECIMALS));
            emit PositionHealthUpdated(user, Math.mulDiv(collateralUsdValue, CR_DENOMINATOR, totalDebt));
        }
    }

    // Helper for burnSynth CR check on remaining position
    function _getCurrentTotalDebtUsdValueExcludingSynthPortion(
        address user, address synthBeingBurned, uint256 amountBurned, uint256 usdValueRepaid
    ) internal view returns (uint256 netTotalDebt) {
        UserPosition storage userPos = positions[user];
        // Iterate all synths, calculate current value, subtract the portion being conceptually removed
        for (uint i = 0; i < synthFactory.getDeployedSynthsCount(); i++) {
            address synthAddr = synthFactory.getDeployedSynthAddressAtIndex(i);
            SynthPositionData storage spd = userPos.synthSpecifics[synthAddr];
            if (spd.amountMinted > 0) {
                SynthFactory.SynthConfig memory synthConf = synthFactory.getSynthConfig(synthAddr);
                uint256 sAssetDecimals = ISynthToken(synthAddr).decimals();
                uint256 price = oracle.getPrice(synthConf.assetId);
                uint256 currentAmount = spd.amountMinted;

                if (synthAddr == synthBeingBurned) {
                    currentAmount -= amountBurned; // Calculate based on remaining amount of this synth
                }
                if(currentAmount > 0) { // only add if there's a remaining amount
                    netTotalDebt += Math.mulDiv(currentAmount, price, (10**sAssetDecimals));
                }
            }
        }
    }

    /**
     * @notice Allows Liquidation Engine to transfer USDC from vault to a specified address
     * @dev This function is called after processLiquidation has reduced user's collateral share
     * @param to Address to transfer USDC to
     * @param amountUsdc Amount of USDC to transfer
     */
    function transferUSDCFromVault(address to, uint256 amountUsdc) external onlyLiquidationEngine {
        usdcToken.safeTransfer(to, amountUsdc);
    }

    /**
     * @notice Allows Liquidation Engine to transfer USDC to the surplus buffer
     * @dev Moves USDC from general pool to explicit surplusBuffer accounting
     * @param amountUsdc Amount of USDC to transfer to surplus buffer
     */
    function transferUSDCFromVaultToSurplus(uint256 amountUsdc) external onlyLiquidationEngine {
        currentSurplusBuffer += amountUsdc;
    }
}
### File: packages/contracts/synth/SynthAdmin.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "../common/access/ProtocolAdminAccess.sol"; // Inherits Ownable
import "./USDCVault.sol";
import "./SynthFactory.sol";
import "./SynthLiquidationEngine.sol"; // Added
import "../common/interfaces/IOracleRelayer.sol";

/**
 * @title SynthAdmin
 * @author Unxversal Team
 * @notice Administrative module for the Unxversal Synthetics protocol.
 * @dev Manages critical parameters and target contract addresses for USDCVault, SynthFactory,
 *      and SynthLiquidationEngine. Owned by a multisig or DAO Timelock.
 *      This contract will be the owner of the core synth protocol contracts.
 */
contract SynthAdmin is ProtocolAdminAccess {
    USDCVault public usdcVault;
    SynthFactory public synthFactory;
    SynthLiquidationEngine public synthLiquidationEngine; // Added
    IOracleRelayer public oracleRelayer; // The OracleRelayerDst contract

    event USDCVaultSet(address indexed vaultAddress);
    event SynthFactorySet(address indexed factoryAddress);
    event SynthLiquidationEngineSet(address indexed engineAddress); // Added
    event OracleRelayerSet(address indexed oracleAddress);
    // Events for parameter changes are typically emitted by the target contracts themselves.

    constructor(
        address _initialOwner,
        address _usdcVault,         // Expected to be deployed already
        address _synthFactory,      // Expected to be deployed already
        address _synthLiquidationEngine, // Expected to be deployed already
        address _oracleRelayer
    ) ProtocolAdminAccess(_initialOwner) {
        // Set target contracts. Ownership of these contracts should be transferred to this SynthAdmin.
        setUSDCVault(_usdcVault);
        setSynthFactory(_synthFactory);
        setSynthLiquidationEngine(_synthLiquidationEngine); // Added
        setOracleRelayer(_oracleRelayer); // This sets it on SynthAdmin for reference
                                          // Individual contracts get it set via their own setters below.
    }

    // --- Target Contract Setters (Callable by SynthAdmin Owner) ---
    // These functions set the addresses in this admin contract.
    // The actual ownership transfer of those target contracts to this admin contract
    // must happen separately (e.g., targetContract.transferOwnership(address(thisSynthAdmin))).

    function setUSDCVault(address _newVaultAddress) public onlyOwner {
        require(_newVaultAddress != address(0), "SynthAdmin: Zero vault address");
        usdcVault = USDCVault(_newVaultAddress);
        emit USDCVaultSet(_newVaultAddress);
    }

    function setSynthFactory(address _newFactoryAddress) public onlyOwner {
        require(_newFactoryAddress != address(0), "SynthAdmin: Zero factory address");
        synthFactory = SynthFactory(_newFactoryAddress);
        emit SynthFactorySet(_newFactoryAddress);
    }

    function setSynthLiquidationEngine(address _newEngineAddress) public onlyOwner { // Added
        require(_newEngineAddress != address(0), "SynthAdmin: Zero liquidation engine address");
        synthLiquidationEngine = SynthLiquidationEngine(_newEngineAddress);
        emit SynthLiquidationEngineSet(_newEngineAddress);
    }

    function setOracleRelayer(address _newOracleAddress) public onlyOwner {
        require(_newOracleAddress != address(0), "SynthAdmin: Zero oracle address for admin ref");
        oracleRelayer = IOracleRelayer(_newOracleAddress);
        emit OracleRelayerSet(_newOracleAddress);
    }


    // --- USDCVault Parameter Management ---
    // These functions call setters on the USDCVault contract.
    // Requires this SynthAdmin contract to be the owner of usdcVault.

    function configureVaultParameters(
        uint256 _newMinCRbps,
        uint256 _newMintFeeBps,
        uint256 _newBurnFeeBps,
        address _newFeeRecipient,
        address _newTreasury,
        uint256 _newSurplusThreshold
    ) external onlyOwner {
        require(address(usdcVault) != address(0), "SynthAdmin: Vault not set");
        usdcVault.setMinCollateralRatio(_newMinCRbps);
        usdcVault.setMintFee(_newMintFeeBps);
        usdcVault.setBurnFee(_newBurnFeeBps);
        usdcVault.setFeeRecipient(_newFeeRecipient);
        usdcVault.setTreasury(_newTreasury);
        usdcVault.setSurplusBufferThreshold(_newSurplusThreshold);
    }

    function setVaultOracle(address _newOracle) external onlyOwner {
        require(address(usdcVault) != address(0), "SynthAdmin: Vault not set");
        usdcVault.setOracle(_newOracle);
    }

    function setVaultSynthFactory(address _newFactory) external onlyOwner {
        require(address(usdcVault) != address(0), "SynthAdmin: Vault not set");
        usdcVault.setSynthFactory(_newFactory);
    }
    
    function setVaultLiquidationEngine(address _newEngine) external onlyOwner {
        require(address(usdcVault) != address(0), "SynthAdmin: Vault not set");
        usdcVault.setLiquidationEngine(_newEngine);
    }

    // --- SynthFactory Parameter Management ---
    // Requires this SynthAdmin contract to be the owner of synthFactory.

    function addSynthToFactory(
        string calldata name,
        string calldata symbol,
        uint256 assetId,
        uint256 customMinCRbps,
        address controllerAddress // Should be address(usdcVault)
    ) external onlyOwner returns (address synthAddress) {
        require(address(synthFactory) != address(0), "SynthAdmin: Factory not set");
        require(controllerAddress == address(usdcVault) && controllerAddress != address(0), "SynthAdmin: Controller must be vault");
        return synthFactory.deploySynth(name, symbol, assetId, customMinCRbps, controllerAddress);
    }

    function setFactorySynthCustomMinCR(address synthAddress, uint256 newCustomMinCRbps) external onlyOwner {
        require(address(synthFactory) != address(0), "SynthAdmin: Factory not set");
        synthFactory.setSynthCustomMinCR(synthAddress, newCustomMinCRbps);
    }

    function setFactoryOracle(address _newOracle) external onlyOwner {
        require(address(synthFactory) != address(0), "SynthAdmin: Factory not set");
        synthFactory.setOracle(_newOracle);
    }

    function transferFactorySynthTokenAdmin(address synthAddress, address newAdmin) external onlyOwner {
        require(address(synthFactory) != address(0), "SynthAdmin: Factory not set");
        synthFactory.transferSynthTokenAdmin(synthAddress, newAdmin);
    }


    // --- SynthLiquidationEngine Parameter Management --- (Added)
    // Requires this SynthAdmin contract to be the owner of synthLiquidationEngine.

    function configureLiquidationEngineParams(
        uint256 _penaltyBps,
        uint256 _rewardShareBps,
        uint256 _maxPortionBps
    ) external onlyOwner {
        require(address(synthLiquidationEngine) != address(0), "SynthAdmin: Liquidation engine not set");
        synthLiquidationEngine.setLiquidationParameters(_penaltyBps, _rewardShareBps, _maxPortionBps);
    }

    function setLiquidationEngineUSDCVault(address _vaultAddress) external onlyOwner {
        require(address(synthLiquidationEngine) != address(0), "SynthAdmin: Liquidation engine not set");
        synthLiquidationEngine.setUSDCVault(_vaultAddress);
    }

    function setLiquidationEngineSynthFactory(address _factoryAddress) external onlyOwner {
        require(address(synthLiquidationEngine) != address(0), "SynthAdmin: Liquidation engine not set");
        synthLiquidationEngine.setSynthFactory(_factoryAddress);
    }

    function setLiquidationEngineOracle(address _oracleAddress) external onlyOwner {
        require(address(synthLiquidationEngine) != address(0), "SynthAdmin: Liquidation engine not set");
        synthLiquidationEngine.setOracle(_oracleAddress);
    }

     function setLiquidationEngineUsdcToken(address _usdcAddress) external onlyOwner {
        require(address(synthLiquidationEngine) != address(0), "SynthAdmin: Liquidation engine not set");
        synthLiquidationEngine.setUsdcToken(_usdcAddress);
    }


    // --- Protocol Pause/Unpause ---
    // These call pause/unpause on the respective contracts.
    // Assumes those contracts implement Pausable and are owned by this SynthAdmin.

    function pauseSynthProtocol() external onlyOwner {
        if (address(usdcVault) != address(0) && !usdcVault.paused()) {
             usdcVault.pauseActions(); // Assuming a function name like this in USDCVault
        }
        if (address(synthFactory) != address(0) && !synthFactory.paused()) {
            synthFactory.pause();
        }
        if (address(synthLiquidationEngine) != address(0) && !synthLiquidationEngine.paused()) {
            synthLiquidationEngine.pauseLiquidations(); // Assuming a function name
        }
    }

    function unpauseSynthProtocol() external onlyOwner {
        if (address(usdcVault) != address(0) && usdcVault.paused()) {
            usdcVault.unpauseActions();
        }
        if (address(synthFactory) != address(0) && synthFactory.paused()) {
            synthFactory.unpause();
        }
        if (address(synthLiquidationEngine) != address(0) && synthLiquidationEngine.paused()) {
            synthLiquidationEngine.unpauseLiquidations();
        }
    }

    // --- Fee/Surplus Management ---
    function sweepVaultSurplusToTreasury() external onlyOwner {
        require(address(usdcVault) != address(0), "SynthAdmin: Vault not set");
        usdcVault.sweepSurplusToTreasury();
    }

    // --- Ownership Transfers of Core Contracts ---
    // Functions to allow this SynthAdmin (owned by DAO Timelock) to transfer ownership
    // of the underlying protocol contracts to a new admin (e.g., a new version of SynthAdmin or directly to DAO).
    function transferUSDCVaultOwnership(address newOwner) external onlyOwner {
        require(address(usdcVault) != address(0), "SynthAdmin: Vault not set");
        usdcVault.transferOwnership(newOwner);
    }

    function transferSynthFactoryOwnership(address newOwner) external onlyOwner {
        require(address(synthFactory) != address(0), "SynthAdmin: Factory not set");
        synthFactory.transferOwnership(newOwner);
    }

    function transferLiquidationEngineOwnership(address newOwner) external onlyOwner {
        require(address(synthLiquidationEngine) != address(0), "SynthAdmin: Liquidation engine not set");
        synthLiquidationEngine.transferOwnership(newOwner);
    }
}
### File: packages/contracts/synth/SynthLiquidationEngine.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/security/Pausable.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

import "./USDCVault.sol";
import "./SynthFactory.sol"; // To get synth info
import "./interfaces/ISynthToken.sol";
import "../common/interfaces/IOracleRelayer.sol"; // For oracle prices

/**
 * @title SynthLiquidationEngine
 * @author Unxversal Team
 * @notice Handles the liquidation of undercollateralized positions in the USDCVault.
 * @dev Allows anyone (keepers) to trigger liquidations. Liquidators repay a portion of
 *      the user's sAsset debt and receive discounted USDC collateral from the user's vault.
 */
contract SynthLiquidationEngine is Ownable, ReentrancyGuard, Pausable {
    using SafeERC20 for IERC20;

    USDCVault public usdcVault;
    SynthFactory public synthFactory;
    IOracleRelayer public oracle;
    IERC20 public usdcToken; // For interacting with USDC

    // Liquidation parameters (configurable by owner)
    uint256 public liquidationPenaltyBps;  // Penalty charged to liquidated user, part becomes liquidator bonus, part to surplus. E.g., 1000 (10%)
    uint256 public liquidatorRewardShareBps; // Share of the penalty that goes to the liquidator. E.g., 5000 (50% of penalty)
    uint256 public maxLiquidationPortionBps; // Max portion of a single sAsset debt that can be liquidated in one call. E.g., 5000 (50%)

    event PositionLiquidated(
        address indexed liquidator,
        address indexed user,
        address indexed synthAddress,
        uint256 amountSynthRepaid,      // Amount of sAsset repaid by liquidator
        uint256 usdValueOfDebtRepaid,   // USD value of the debt (at user's mint avg) cleared for user
        uint256 usdcCollateralSeized,   // Total USDC taken from user's collateral
        uint256 usdcToLiquidator,       // USDC portion paid to liquidator
        uint256 usdcToSurplusBuffer     // USDC portion paid to surplus buffer
    );

    // Admin parameter change events
    event LiquidationParamsSet(uint256 penaltyBps, uint256 rewardShareBps, uint256 maxPortionBps);
    event VaultSet(address vaultAddress);
    event FactorySet(address factoryAddress);
    event OracleSet(address oracleAddress);
    event UsdcTokenSet(address usdcAddress);


    constructor(
        address _usdcVaultAddress,
        address _synthFactoryAddress,
        address _oracleAddress,
        address _usdcTokenAddress,
        address _initialOwner
    ) Ownable(_initialOwner) {
        setUSDCVault(_usdcVaultAddress);
        setSynthFactory(_synthFactoryAddress);
        setOracle(_oracleAddress);
        setUsdcToken(_usdcTokenAddress);
        // Default liquidation params should be set by owner post-deployment
    }

    // --- Admin Functions ---
    function setLiquidationParameters(
        uint256 _penaltyBps,
        uint256 _rewardShareBps,
        uint256 _maxPortionBps
    ) external onlyOwner {
        require(_penaltyBps > 0 && _penaltyBps <= 2500, "SLE: Invalid penalty"); // Max 25% example
        require(_rewardShareBps <= 10000, "SLE: Invalid reward share"); // Can be up to 100% of penalty
        require(_maxPortionBps > 0 && _maxPortionBps <= 10000, "SLE: Invalid max portion"); // Up to 100%
        liquidationPenaltyBps = _penaltyBps;
        liquidatorRewardShareBps = _rewardShareBps;
        maxLiquidationPortionBps = _maxPortionBps;
        emit LiquidationParamsSet(_penaltyBps, _rewardShareBps, _maxPortionBps);
    }

    function setUSDCVault(address _vaultAddress) public onlyOwner {
        require(_vaultAddress != address(0), "SLE: Zero vault");
        usdcVault = USDCVault(_vaultAddress);
        emit VaultSet(_vaultAddress);
    }
    function setSynthFactory(address _factoryAddress) public onlyOwner {
        require(_factoryAddress != address(0), "SLE: Zero factory");
        synthFactory = SynthFactory(_factoryAddress);
        emit FactorySet(_factoryAddress);
    }
    function setOracle(address _oracleAddress) public onlyOwner {
        require(_oracleAddress != address(0), "SLE: Zero oracle");
        oracle = IOracleRelayer(_oracleAddress);
        emit OracleSet(_oracleAddress);
    }
    function setUsdcToken(address _usdcAddress) public onlyOwner {
        require(_usdcAddress != address(0), "SLE: Zero USDC");
        usdcToken = IERC20(_usdcAddress);
        emit UsdcTokenSet(_usdcAddress);
    }
    function pauseLiquidations() external onlyOwner { _pause(); }
    function unpauseLiquidations() external onlyOwner { _unpause(); }

    // --- Liquidation Function ---
    /**
     * @notice Liquidates an undercollateralized position for a specific sAsset.
     * @dev Anyone can call this. The caller (liquidator) must provide `amountSynthToRepay` of the sAsset.
     *      Liquidator first approves this contract for `amountSynthToRepay` of `synthToRepayAddress`.
     * @param user The address of the user whose position is being liquidated.
     * @param synthToRepayAddress The address of the sAsset for which debt is being repaid.
     * @param amountSynthToRepay The amount of sAsset the liquidator will repay on behalf of the user.
     *                           This amount is burned from the liquidator.
     */
    function liquidatePosition(
        address user,
        address synthToRepayAddress,
        uint256 amountSynthToRepay
    ) external nonReentrant whenNotPaused {
        require(address(usdcVault) != address(0), "SLE: Vault not set");
        require(address(synthFactory) != address(0), "SLE: Factory not set");
        require(address(oracle) != address(0), "SLE: Oracle not set");
        require(liquidationPenaltyBps > 0, "SLE: Liquidation not configured");

        // 1. Check if position is liquidatable (CR < minCR)
        // This check should be comprehensive, considering all user's debts vs collateral.
        // USDCVault's `isPositionLiquidatable` gives a general idea.
        // A more precise check here would involve fetching all user's synth positions.
        // For now, rely on USDCVault's view or assume liquidator has verified.
        // For safety, this contract should re-verify using current prices.
        require(usdcVault.isPositionLiquidatable(user), "SLE: Position not liquidatable by vault's check");

        // Get synth details from factory and vault
        SynthFactory.SynthConfig memory synthConfig = synthFactory.getSynthConfig(synthToRepayAddress);
        require(synthConfig.isRegistered, "SLE: Synth not registered");
        USDCVault.UserPosition storage userPos = usdcVault.positions(user); // Get storage pointer
        USDCVault.SynthPositionData storage userSynthPos = userPos.synthSpecifics[synthToRepayAddress];

        require(userSynthPos.amountMinted > 0, "SLE: User has no debt for this synth");

        // 2. Determine actual amount of sAsset to liquidate (up to maxPortion or full debt)
        uint256 maxRepayableSynth = (userSynthPos.amountMinted * maxLiquidationPortionBps) / BPS_DENOMINATOR;
        uint256 actualSynthToRepay = Math.min(amountSynthToRepay, maxRepayableSynth);
        require(actualSynthToRepay > 0, "SLE: Repay amount is zero after cap");
        require(actualSynthToRepay <= userSynthPos.amountMinted, "SLE: Repay amount exceeds user debt for synth");

        // 3. Liquidator provides sAssets: Burn sAssets from liquidator
        // Liquidator must have approved this contract for `actualSynthToRepay` of `synthToRepayAddress`.
        ISynthToken(synthToRepayAddress).burnFrom(_msgSender(), actualSynthToRepay);

        // 4. Calculate USD value of the debt being repaid by liquidator for the user
        // This uses the user's average mint price for that sAsset to determine "book value" of debt cleared.
        uint256 usdValueOfDebtClearedForUser;
        if (userSynthPos.amountMinted > 0) { // Should be true due to earlier check
            usdValueOfDebtClearedForUser = Math.mulDiv(
                actualSynthToRepay,
                userSynthPos.totalUsdValueAtMint,
                userSynthPos.amountMinted // Use original total before this liquidation part
            );
        } else {
            revert("SLE: Inconsistent state for debt value calc");
        }
        
        // 5. Calculate total USDC value of collateral to take from user
        // This is the USD value of debt cleared + penalty on that value.
        uint256 penaltyAmountUsd = (usdValueOfDebtClearedForUser * liquidationPenaltyBps) / BPS_DENOMINATOR;
        uint256 totalUsdcValueFromUser = usdValueOfDebtClearedForUser + penaltyAmountUsd;

        // Ensure user has enough collateral to cover this
        // Convert totalUsdcValueFromUser to USDC units (assuming 6 decimals for USDC)
        uint256 usdcToTakeFromUser = totalUsdcValueFromUser * (10**USDCVault.USDC_DECIMALS) / PRICE_PRECISION;
        require(userPos.usdcCollateral >= usdcToTakeFromUser, "SLE: Insufficient user collateral for liquidation");

        // 6. Update user's position in USDCVault: reduce debt, reduce collateral
        // This call tells USDCVault what happened.
        // The `collateralToSeizeAmountUsdc` for Vault's `processLiquidation` is `usdcToTakeFromUser`.
        usdcVault.processLiquidation(user, synthToRepayAddress, actualSynthToRepay, usdcToTakeFromUser);
        // After this, user's `usdcCollateral` in vault is reduced by `usdcToTakeFromUser`.
        // User's `amountMinted` and `totalUsdValueAtMint` for `synthToRepayAddress` are reduced.

        // 7. Distribute the seized USDC collateral (`usdcToTakeFromUser`)
        // It's currently "held" by this LiquidationEngine implicitly because USDCVault reduced user's balance.
        // Now, transfer it from USDCVault (which holds all USDC) to liquidator and surplus buffer.

        uint256 liquidatorRewardUsd = (penaltyAmountUsd * liquidatorRewardShareBps) / BPS_DENOMINATOR;
        uint256 usdcToLiquidator = liquidatorRewardUsd * (10**USDCVault.USDC_DECIMALS) / PRICE_PRECISION;
        
        // The remaining part of `totalUsdcValueFromUser` goes to surplus/system.
        // `usdValueOfDebtClearedForUser` effectively covers the "hole" left by the sAsset debt.
        // `penaltyAmountUsd` is the extra.
        // `liquidatorRewardUsd` is part of `penaltyAmountUsd`.
        // `surplusContributionUsd = penaltyAmountUsd - liquidatorRewardUsd`.
        uint256 surplusContributionUsd = penaltyAmountUsd - liquidatorRewardUsd;
        uint256 usdcToSurplus = surplusContributionUsd * (10**USDCVault.USDC_DECIMALS) / PRICE_PRECISION;

        // Transfer USDC from the Vault to liquidator and to surplus buffer (managed by Vault)
        if (usdcToLiquidator > 0) {
            // Vault needs a function to allow LE to transfer out, or LE holds USDC temporarily.
            // For simplicity, assume Vault transfers directly if called by LE.
            // Or, LE is given allowance on Vault's USDC (less ideal).
            // Let's make Vault transfer. Modify Vault.processLiquidation or add a new function.
            // **This requires a change in USDCVault or a specific withdrawal function callable by LE.**
            // For now, assume this contract gets the USDC and distributes it.
            // This implies `usdcVault.processLiquidation` might have transferred `usdcToTakeFromUser` to `address(this)`.
            // This is a CRITICAL flow detail.
            // Let's assume `USDCVault` has a function like:
            // `releaseCollateralForLiquidation(address recipient, uint256 amountUsdc)` callable by LE.
            
            // If `USDCVault.processLiquidation` only updates balances, then this contract
            // needs to be able to pull the `usdcToTakeFromUser` from `USDCVault`.
            // This means `USDCVault` needs to `approve` this `SynthLiquidationEngine` for its total USDC balance,
            // OR `USDCVault` needs specific authenticated withdrawal functions.
            // The latter is safer.

            // **Revised Flow Assumption:**
            // `USDCVault` has: `transferUSDCFromVault(address to, uint256 amount)` callable by LE.
            // This `SynthLiquidationEngine` would need to be registered with `USDCVault`.
            // Let's assume `USDCVault` has a method `executeLiquidationPayouts(address liquidator, uint256 amountToLiquidator, address surplus, uint256 amountToSurplus)`
            // callable only by `liquidationEngine`.

            usdcVault.transferUSDCFromVault(_msgSender(), usdcToLiquidator); // To liquidator
            if (usdcToSurplus > 0) {
                 usdcVault.transferUSDCFromVaultToSurplus(usdcToSurplus); // To Vault's surplus
            }
        }


        emit PositionLiquidated(
            _msgSender(), user, synthToRepayAddress, actualSynthToRepay,
            usdValueOfDebtClearedForUser, usdcToTakeFromUser,
            usdcToLiquidator, usdcToSurplus
        );
    }

    // --- View Functions ---
    /** @notice Checks if a user's specific synth position is liquidatable based on its current value and effective CR. */
    function checkSynthLiquidatability(address user, address synthAddress)
        external view returns (bool isLiquidatable, uint256 currentCRbps)
    {
        // This is a more focused check than vault's general one.
        USDCVault.UserPosition memory userPos = usdcVault.positions(user); // Read from storage
        if (userPos.usdcCollateral == 0) return (false, type(uint256).max);

        SynthFactory.SynthConfig memory synthConfig = synthFactory.getSynthConfig(synthAddress);
        if (!synthConfig.isRegistered || userPos.synthSpecifics[synthAddress].amountMinted == 0) {
            return (false, usdcVault.getCollateralizationRatio(user)); // Return overall CR if this synth not part of debt
        }

        uint256 currentTotalDebtUsd = usdcVault._getCurrentTotalDebtUsdValueForHealthCheck(user); // Uses the gas-heavy helper
        if (currentTotalDebtUsd == 0) return (false, type(uint256).max);

        uint256 collateralUsdValue = userPos.usdcCollateral * (PRICE_PRECISION / (10**USDCVault.USDC_DECIMALS));
        currentCRbps = Math.mulDiv(collateralUsdValue, CR_DENOMINATOR, currentTotalDebtUsd);

        uint256 effectiveMinCRbps = synthConfig.customMinCRbps > 0 ? synthConfig.customMinCRbps : usdcVault.minCollateralRatioBps();
        
        isLiquidatable = currentCRbps < effectiveMinCRbps && effectiveMinCRbps > 0;
        return (isLiquidatable, currentCRbps);
    }
}
### File: packages/contracts/synth/SynthToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./interfaces/ISynthToken.sol";
import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol"; // Provides burnFrom
import "@openzeppelin/contracts/access/extensions/AccessControlEnumerable.sol";

/**
 * @title SynthToken
 * @author Unxversal Team
 * @notice Base ERC20 implementation for synthetic assets (sAssets).
 * @dev Minting is restricted via MINTER_ROLE. Burning (via burnFrom) is restricted via BURNER_ROLE.
 *      These roles are typically granted to the USDCVault contract.
 *      The deployer receives DEFAULT_ADMIN_ROLE for initial role setup.
 */
contract SynthToken is ERC20, ERC20Burnable, AccessControlEnumerable, ISynthToken {
    bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");
    bytes32 public constant BURNER_ROLE = keccak256("BURNER_ROLE");

    // Optional: Store assetId for easier identification off-chain if needed by other contracts.
    // uint256 public immutable assetIdForOracle;

    /**
     * @param name_ Name of the synthetic asset (e.g., "Unxversal Bitcoin").
     * @param symbol_ Symbol of the synthetic asset (e.g., "sBTC").
     * @param initialAdmin The address to receive DEFAULT_ADMIN_ROLE for this token.
     *                     Typically the SynthFactory or a central DAO Timelock.
     */
    constructor(
        string memory name_,
        string memory symbol_,
        address initialAdmin // Address that can grant MINTER/BURNER roles
        // uint256 _assetIdForOracle // Optional
    ) ERC20(name_, symbol_) {
        require(initialAdmin != address(0), "SynthToken: Zero admin");
        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);
        // MINTER_ROLE and BURNER_ROLE will be granted by the admin (e.g., SynthFactory)
        // to the USDCVault contract after deployment of this SynthToken.
        // assetIdForOracle = _assetIdForOracle; // Optional
    }

    /**
     * @inheritdoc ISynthToken
     * @dev Mints `amount` of tokens to `to`. Only callable by an account with MINTER_ROLE.
     */
    function mint(address to, uint256 amount) public virtual override {
        require(hasRole(MINTER_ROLE, _msgSender()), "SynthToken: Caller is not a minter");
        _mint(to, amount);
    }

    /**
     * @notice Destroys `amount` tokens from `account`, reducing the total supply.
     * @dev Overrides ERC20Burnable.burnFrom to restrict access to BURNER_ROLE.
     *      The caller (with BURNER_ROLE, e.g., USDCVault) must have been approved by `account`
     *      to spend at least `amount` of tokens.
     * @param account The account whose tokens will be burnt.
     * @param amount The amount of tokens to burn.
     */
    function burnFrom(address account, uint256 amount) public virtual override {
        require(hasRole(BURNER_ROLE, _msgSender()), "SynthToken: Caller is not a burner");
        // The allowance check is handled by super.burnFrom() in ERC20Burnable
        super.burnFrom(account, amount);
    }

    // --- AccessControlEnumerable Overrides for OZ v5 ---
    // (supportsInterface from AccessControlEnumerable will cover roles)
    function supportsInterface(bytes4 interfaceId)
        public view virtual override(AccessControlEnumerable) returns (bool)
    {
        return interfaceId == type(ISynthToken).interfaceId ||
               super.supportsInterface(interfaceId);
    }
}
### File: packages/contracts/synth/interfaces/ISynthToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title ISynthToken
 * @author Unxversal Team
 * @notice Interface for synthetic asset (sAsset) tokens.
 * @dev Extends IERC20 with a controlled minting function. Burning is handled
 *      via ERC20Burnable's `burnFrom` by an authorized controller.
 */
interface ISynthToken is IERC20 {
    /**
     * @notice Mints new synth tokens to an account.
     * @dev Typically only callable by a trusted minter (e.g., USDCVault).
     * @param to The address to mint tokens to.
     * @param amount The amount of tokens to mint.
     */
    function mint(address to, uint256 amount) external;

    // ERC20Burnable's `burnFrom(address account, uint256 amount)` will be used by the controller.
    // No separate `burn(address from, ...)` needed in this interface if controller uses `burnFrom`.
}
### File: packages/contracts/dex/DexFeeSwitch.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol"; // To set fee recipient once
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";

/**
 * @title DexFeeSwitch
 * @author Unxversal Team
 * @notice Manages the collection and distribution of trading fees for the Unxversal DEX.
 * @dev This contract is designed to be immutable regarding its fee logic after deployment.
 *      The fee recipient can be set once by the owner (deployer/DAO).
 *      It collects fees in various tokens and expects an off-chain or DAO-governed
 *      process to swap these fees to a standard denomination (e.g., USDC) if desired.
 *      Your spec mentioned: "All fee destinations ... are USDC-denominated. Fees received in other
 *      assets are auto-swapped to USDC via a whitelisted route at the time of deposit."
 *      This contract will *collect* them. The auto-swap would be a separate mechanism
 *      interacting with this contract's collected fees or triggered by the `depositFee` function
 *      if it had swap capabilities (which adds complexity and gas). For V1, simple collection.
 */
contract DexFeeSwitch {
    using SafeERC20 for IERC20;

    address public immutable feeRecipient; // Can be a treasury, multisig, or another contract
    bool public constant recipientIsSet = true; // To indicate it's set (as it's immutable)

    // If you want to allow setting it once post-deployment instead of constructor:
    // address public feeRecipient;
    // bool public recipientIsSet;
    // address public owner; // To set the feeRecipient

    event FeeRecipientSet(address indexed recipient);
    event FeeDeposited(address indexed token, address indexed payer, address indexed recipient, uint256 amount);

    /**
     * @param _initialFeeRecipient The address that will receive all collected fees.
     *                           Cannot be the zero address.
     */
    constructor(address _initialFeeRecipient) {
        require(_initialFeeRecipient != address(0), "DexFeeSwitch: Zero fee recipient");
        feeRecipient = _initialFeeRecipient;
        emit FeeRecipientSet(_initialFeeRecipient);
    }

    // If allowing one-time set post-deployment:
    // constructor() { owner = msg.sender; }
    // function setFeeRecipient(address _newFeeRecipient) external {
    //     require(msg.sender == owner, "DexFeeSwitch: Not owner");
    //     require(!recipientIsSet, "DexFeeSwitch: Recipient already set");
    //     require(_newFeeRecipient != address(0), "DexFeeSwitch: Zero fee recipient");
    //     feeRecipient = _newFeeRecipient;
    //     recipientIsSet = true;
    //     emit FeeRecipientSet(_newFeeRecipient);
    // }


    /**
     * @notice Called by the OrderNFT contract (or other fee-generating contracts) to deposit fees.
     * @dev This function pulls the fee amount from the `payer` (typically the OrderNFT contract itself,
     *      which would have received the tokens from users).
     * @param token The ERC20 token address of the fee being deposited.
     * @param payer The address from which to pull the fee (must have approved this contract).
     * @param amount The amount of the fee to deposit.
     */
    function depositFee(address token, address payer, uint256 amount) external {
        require(recipientIsSet, "DexFeeSwitch: Fee recipient not set");
        require(amount > 0, "DexFeeSwitch: Zero fee amount");
        require(payer != address(0), "DexFeeSwitch: Zero payer address"); // Should be the OrderNFT contract

        IERC20(token).safeTransferFrom(payer, feeRecipient, amount);

        emit FeeDeposited(token, payer, feeRecipient, amount);
    }

    /**
     * @notice Allows the feeRecipient (or a designated admin if this contract becomes Ownable
     *         and has more complex logic) to withdraw collected fees for a specific token.
     * @dev This is primarily useful if fees accumulate here before being swept.
     *      If feeRecipient is an EOA, they don't need this. If it's a contract, it might.
     *      However, direct `safeTransferFrom` to `feeRecipient` in `depositFee` is simpler.
     *      This function is only useful if this contract itself holds balances.
     *      Given the `safeTransferFrom` in `depositFee`, this contract should not hold balances.
     *      If the goal is for this contract to *accumulate* fees and then have the recipient
     *      claim them (or for an auto-swap mechanism to pull from here), then `depositFee`
     *      should transfer to `address(this)`.
     *
     *      Revisiting spec: "All fee destinations ... are USDC-denominated. Fees received in other assets
     *      are auto-swapped ... at the time of deposit." This implies `depositFee` might interact with
     *      a router. For V1 simplicity, let's assume `depositFee` sends directly to `feeRecipient`.
     *      If an auto-swap is desired, `depositFee` becomes more complex.
     *
     *      If `feeRecipient` is a contract that *performs* the auto-swap:
     *      The current `depositFee` sends tokens directly to `feeRecipient`. That recipient contract
     *      would then handle any swaps. This DexFeeSwitch remains simple.
     */

    // To support the "auto-swap to USDC" feature more directly within this contract (adds complexity):
    // address public usdcToken;
    // IUniswapV2Router02 public uniswapRouter; // Example router
    // mapping(address => address[]) public swapPathToUsdc; // tokenIn => [tokenIn, weth, usdc]

    // function setUniswapRouter(address _router) external onlyOwner;
    // function setUsdcToken(address _usdc) external onlyOwner;
    // function setSwapPath(address _tokenIn, address[] calldata _path) external onlyOwner;

    // function depositFeeAndSwapToUsdc(address tokenIn, address payer, uint256 amountIn) external {
    //     require(recipientIsSet, "Recipient not set");
    //     IERC20(tokenIn).safeTransferFrom(payer, address(this), amountIn);
    //     _approveTokenIfNeeded(tokenIn, address(uniswapRouter), amountIn);
    //     uint256 balanceBefore = IERC20(usdcToken).balanceOf(feeRecipient);
    //     uniswapRouter.swapExactTokensForTokens(...); // perform swap
    //     uint256 balanceAfter = IERC20(usdcToken).balanceOf(feeRecipient);
    //     emit FeeDeposited(usdcToken, payer, feeRecipient, balanceAfter - balanceBefore);
    // }

    // For now, sticking to the simpler direct deposit model. Auto-swap can be a V2 or
    // handled by the `feeRecipient` contract if it's a smart contract.
}
### File: packages/contracts/dex/OrderNFT.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

/* ──────────────── OpenZeppelin ──────────────── */
import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol";
import "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";
import "@openzeppelin/contracts/utils/Strings.sol";

/* ──────────────── Project deps ──────────────── */
import "./DexFeeSwitch.sol";
import "./utils/PermitHelper.sol";
import "../interfaces/structs/SPermit2.sol";
import "../interfaces/IPermit2.sol";

/**
 * @title OrderNFT
 * @author Unxversal Team
 * @notice ERC-721 that escrows sell-tokens and represents a limit order.
 */
contract OrderNFT is ERC721, ERC721Enumerable, ERC721URIStorage, ReentrancyGuard, Ownable {
    using SafeERC20 for IERC20;

    /* ──────────────── Storage ──────────────── */

    struct Order {
        address  maker;
        uint32   expiry;
        uint24   feeBpsTaken;
        uint8    sellDecimals;
        uint256  amountInitial;
        uint256  amountRemaining;
        address  sellToken;
        address  buyToken;
        uint256  price;          // PRICE_PRECISION scaled
        bool     isConcluded;
    }

    mapping(uint256 => Order) public orders;
    uint256 private _nextTokenId;

    DexFeeSwitch public immutable dexFeeSwitch;
    PermitHelper public immutable permitHelper;

    uint256 public constant PRICE_PRECISION = 1e18;
    uint256 public constant MAX_FEE_BPS     = 1000; // 10 %
    uint256 public constant BPS_DENOMINATOR = 10_000;

    /* ──────────────── Events ──────────────── */
    // ↳ max. 3 indexed parameters allowed
    event OrderCreated(
        uint256 indexed tokenId,
        address indexed maker,
        address indexed sellToken,
        address buyToken,
        uint256 price,
        uint256 amountInitial,
        uint32  expiry,
        uint8   sellDecimals,
        uint24  feeBps
    );

    event OrderFilled(
        uint256 indexed tokenId,
        address indexed taker,
        address indexed maker,
        uint256 amountSold,
        uint256 amountBoughtNet,
        uint256 feeAmount,
        uint256 amountRemainingInOrder
    );

    event OrderCancelled(
        uint256 indexed tokenId,
        address  indexed maker,
        uint256 amountReturned
    );

    /* ──────────────── Constructor ──────────────── */
    constructor(
        string memory name_,
        string memory symbol_,
        address      _dexFeeSwitch,
        address      _permitHelper,
        address      initialOwner
    ) ERC721(name_, symbol_) Ownable(initialOwner) {
        require(_dexFeeSwitch  != address(0), "OrderNFT: fee switch 0");
        require(_permitHelper  != address(0), "OrderNFT: permit helper 0");
        dexFeeSwitch = DexFeeSwitch(_dexFeeSwitch);
        permitHelper = PermitHelper(_permitHelper);
    }

    /* ──────────────── Order creation (manual approve) ──────────────── */
    function createOrder(
        address sellTokenAddr,
        address buyTokenAddr,
        uint256 pricePerUnitOfSellToken,
        uint256 amountToSell,
        uint32  expiry_,
        uint8   sellDecimals_,
        uint24  orderFeeBps_
    ) external nonReentrant returns (uint256 tokenId) {
        /* validation */
        require(sellTokenAddr != address(0) && buyTokenAddr != address(0), "OrderNFT: zero token");
        require(sellTokenAddr != buyTokenAddr,                         "OrderNFT: same token");
        require(amountToSell   > 0,                                    "OrderNFT: zero amount");
        require(pricePerUnitOfSellToken > 0,                           "OrderNFT: zero price");
        require(expiry_  > block.timestamp,                            "OrderNFT: expiry past");
        require(orderFeeBps_ <= MAX_FEE_BPS,                           "OrderNFT: fee > max");

        /* escrow sell-token */
        IERC20(sellTokenAddr).safeTransferFrom(msg.sender, address(this), amountToSell);

        /* mint order NFT */
        tokenId = ++_nextTokenId;
        orders[tokenId] = Order({
            maker:           msg.sender,
            expiry:          expiry_,
            feeBpsTaken:     orderFeeBps_,
            sellDecimals:    sellDecimals_,
            amountInitial:   amountToSell,
            amountRemaining: amountToSell,
            sellToken:       sellTokenAddr,
            buyToken:        buyTokenAddr,
            price:           pricePerUnitOfSellToken,
            isConcluded:     false
        });

        _safeMint(msg.sender, tokenId);

        emit OrderCreated(
            tokenId, msg.sender, sellTokenAddr, buyTokenAddr, pricePerUnitOfSellToken,
            amountToSell, expiry_, sellDecimals_, orderFeeBps_
        );
    }

    /* ──────────────── Filling orders ──────────────── */
    function fillOrders(
        uint256[] calldata tokenIds,
        uint256[] calldata amountsToFill /* sell-token amounts */
    ) external nonReentrant {
        require(tokenIds.length == amountsToFill.length && tokenIds.length != 0,
                "OrderNFT: length mismatch");

        address taker = msg.sender;

        for (uint256 i; i < tokenIds.length; ++i) {
            uint256 tokenId  = tokenIds[i];
            uint256 wantSell = amountsToFill[i];
            require(wantSell > 0, "OrderNFT: zero fill");

            Order storage o = orders[tokenId];
            require(!o.isConcluded,                "OrderNFT: concluded");
            require(ownerOf(tokenId) == o.maker,   "OrderNFT: maker no hold");
            require(block.timestamp < o.expiry,    "OrderNFT: expired");
            require(o.amountRemaining > 0,         "OrderNFT: filled");

            uint256 sellAmt = Math.min(wantSell, o.amountRemaining);
            uint256 buyGross = Math.mulDiv(sellAmt, o.price, PRICE_PRECISION);

            uint256 fee = (buyGross * o.feeBpsTaken) / BPS_DENOMINATOR;
            uint256 buyNet = buyGross - fee;

            /* taker pays buyToken */
            IERC20(o.buyToken).safeTransferFrom(taker, address(this), buyGross);

            if (fee > 0) {
                IERC20(o.buyToken).approve(address(dexFeeSwitch), fee);
                dexFeeSwitch.depositFee(o.buyToken, address(this), fee);
            }
            if (buyNet > 0) IERC20(o.buyToken).safeTransfer(o.maker, buyNet);

            /* taker receives sellToken */
            IERC20(o.sellToken).safeTransfer(taker, sellAmt);

            /* state update */
            o.amountRemaining -= sellAmt;
            if (o.amountRemaining == 0) o.isConcluded = true;

            emit OrderFilled(
                tokenId, taker, o.maker, sellAmt, buyNet, fee, o.amountRemaining
            );
        }
    }

    /* ──────────────── Cancel order ──────────────── */
    function cancelOrder(uint256 tokenId) external nonReentrant {
        Order storage o = orders[tokenId];
        require(ownerOf(tokenId) == msg.sender, "OrderNFT: not owner");
        require(o.maker           == msg.sender, "OrderNFT: not maker");
        require(!o.isConcluded,                 "OrderNFT: done");

        uint256 refund = o.amountRemaining;
        o.amountRemaining = 0;
        o.isConcluded     = true;

        if (refund > 0) IERC20(o.sellToken).safeTransfer(o.maker, refund);
        emit OrderCancelled(tokenId, o.maker, refund);
    }

    /* ──────────────── Permit helpers (unchanged) ──────────────── */
    /// …  (createOrderWithPermitERC2612 / createOrderWithPermit2 and _createOrderAuthorized unchanged)
    /// For brevity, these functions are identical to the previous code block
    /// and are omitted here. The compilation fixes concern only OZ-5 clashes.

    /* ──────────────── Metadata ──────────────── */
    function _baseURI() internal pure override returns (string memory) {
        return "https://example.com/";
    }

    function tokenURI(uint256 tokenId)
        public view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        _requireOwned(tokenId);
        return string(abi.encodePacked(_baseURI(), Strings.toString(tokenId)));
    }

    /* ──────────────── OpenZeppelin 5 hook reconciliation ──────────────── */
    function _increaseBalance(address account, uint128 value)
        internal
        override(ERC721, ERC721Enumerable)
    {
        super._increaseBalance(account, value); // Enumerable keeps its own counters
    }

    function _update(address to, uint256 tokenId, address auth)
        internal
        override(ERC721, ERC721Enumerable)
        returns (address from)
    {
        from = super._update(to, tokenId, auth); // each base updates its own state
    }

    /* ──────────────── Interface support ──────────────── */
    function supportsInterface(bytes4 interfaceId)
        public view
        override(ERC721, ERC721Enumerable, ERC721URIStorage)
        returns (bool)
    {
        return super.supportsInterface(interfaceId);
    }
}

### File: packages/contracts/dex/utils/PermitHelper.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol";
// Corrected import path assuming IPermit2.sol is in "../../interfaces/" relative to this file
import "../../interfaces/IPermit2.sol"; 
import {
    PermitBatchTransferFrom,
    SignatureTransferDetails,
    PermitTransferFrom
} from "../../interfaces/structs/SPermit2.sol";

/**
 * @title PermitHelper
 * @author Unxversal Team
 * @notice Helper contract to facilitate ERC2612 (EIP-2612) and Uniswap Permit2 signatures.
 * @dev Allows users to approve token spending and execute an action (like creating or filling an order)
 *      in a single transaction by providing a signature.
 *      This contract itself should not hold tokens or approvals long-term.
 *      It acts as a temporary dispatcher for permitted actions.
 */
contract PermitHelper {
    IPermit2 public immutable permit2Contract;

    event ERC2612PermitUsed(
        address indexed owner,
        address indexed token,
        address indexed spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s
    );
    // An event for Permit2 could be useful, e.g., when permitTransferFrom is called via this helper
    event Permit2TransferExecuted(
        address indexed owner,
        address indexed token, // From permit.permitted[0].token or permit.permitted.token
        address indexed to,    // From transferDetails[0].to or transferDetails.to
        uint256 amount         // From transferDetails[0].requestedAmount or transferDetails.requestedAmount
    );


    constructor(address _permit2Address) {
        require(_permit2Address != address(0), "PermitHelper: Zero Permit2 address");
        permit2Contract = IPermit2(_permit2Address);
    }

    // Note: The internal `useERC2612Permit` function was primarily for illustration.
    // The external `erc2612PermitAndCall` directly uses `token.permit()`.
    // If you needed `useERC2612Permit` for other internal logic, it could be kept.
    // For now, it's not strictly necessary if only `erc2612PermitAndCall` is used.

    /**
     * @notice Executes an ERC2612 permit and then calls a target contract.
     * @param token The ERC20 token that supports EIP-2612.
     * @param owner The owner of the tokens.
     * @param spender The address to be approved (typically the targetContract or a related vault).
     * @param value The amount of tokens to approve.
     * @param deadline The deadline after which the EIP-2612 signature is invalid.
     * @param v v component of the EIP-2612 signature.
     * @param r r component of the EIP-2612 signature.
     * @param s s component of the EIP-2
     * @param targetContract The contract to call after the permit is processed.
     * @param callData The encoded function call data for the targetContract.
     * @return result The data returned by the targetContract call.
     */
    function erc2612PermitAndCall(
        IERC20Permit token,
        address owner,
        address spender,
        uint256 value,
        uint256 deadline,
        uint8 v,
        bytes32 r,
        bytes32 s,
        address targetContract,
        bytes calldata callData
    ) external returns (bytes memory result) {
        require(targetContract != address(0), "PermitHelper: Zero target contract");
        token.permit(owner, spender, value, deadline, v, r, s);
        emit ERC2612PermitUsed(owner, address(token), spender, value, deadline, v, r, s);

        (bool success, bytes memory returnedData) = targetContract.call(callData);
        require(success, "PermitHelper: Target call failed"); // Consider bubbling up revert reason
        return returnedData;
    }

    /**
     * @notice Executes a Permit2 permitTransferFrom (batch) and then calls a target contract.
     * @dev The `transferDetails[i].to` field specifies the recipient of each permitted transfer.
     * @param permit The PermitBatchTransferFrom data signed by the owner.
     * @param transferDetails Array of SignatureTransferDetails specifying destinations and amounts.
     * @param owner The owner of the tokens who signed the permit.
     * @param signature The EIP-712 signature from the owner.
     * @param targetContract The contract to call after the Permit2 transfers are processed.
     * @param callData The encoded function call data for the targetContract.
     * @return result The data returned by the targetContract call.
     */
    function permit2BatchTransferAndCall(
        PermitBatchTransferFrom memory permit, // Using IPermit2 scope for the struct
        SignatureTransferDetails[] calldata transferDetails, // Using IPermit2 scope
        address owner,
        bytes calldata signature,
        address targetContract,
        bytes calldata callData
    ) external returns (bytes memory result) {
        require(targetContract != address(0), "PermitHelper: Zero target contract");
        permit2Contract.permitTransferFrom(permit, transferDetails, owner, signature);

        // Emit an event for at least the first transfer for traceability
        if (transferDetails.length > 0 && permit.permitted.length > 0) {
            emit Permit2TransferExecuted(
                owner,
                permit.permitted[0].token,
                transferDetails[0].to,
                transferDetails[0].requestedAmount
            );
        }

        (bool success, bytes memory returnedData) = targetContract.call(callData);
        require(success, "PermitHelper: Target call failed"); // Consider bubbling up revert reason
        return returnedData;
    }

    /**
     * @notice Executes a Permit2 permitTransferFrom (single) and then calls a target contract.
     * @dev The `transferDetails.to` field specifies the recipient of the permitted transfer.
     * @param permit The PermitTransferFrom data signed by the owner.
     * @param transferDetails SignatureTransferDetails specifying destination and amount.
     * @param owner The owner of the tokens who signed the permit.
     * @param signature The EIP-712 signature from the owner.
     * @param targetContract The contract to call after the Permit2 transfer is processed.
     * @param callData The encoded function call data for the targetContract.
     * @return result The data returned by the targetContract call.
     */
    function permit2SingleTransferAndCall(
        PermitTransferFrom memory permit, // Using IPermit2 scope for the struct
        SignatureTransferDetails calldata transferDetails, // Using IPermit2 scope
        address owner,
        bytes calldata signature,
        address targetContract,
        bytes calldata callData
    ) external returns (bytes memory result) {
        require(targetContract != address(0), "PermitHelper: Zero target contract");
        permit2Contract.permitTransferFrom(permit, transferDetails, owner, signature);

        emit Permit2TransferExecuted(
            owner,
            permit.permitted.token,
            transferDetails.to,
            transferDetails.requestedAmount
        );

        (bool success, bytes memory returnedData) = targetContract.call(callData);
        require(success, "PermitHelper: Target call failed"); // Consider bubbling up revert reason
        return returnedData;
    }
}
### File: packages/contracts/dex/structs/SOrder.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

// @dev Note: This struct defines the logical data of an order.
// The OrderNFT contract will manage how these fields are stored per tokenId,
// aiming for gas efficiency (e.g., packing some fields, storing others directly).
struct OrderLayout {
    address maker;
    uint32 expiry;
    uint24 feeBps; // Fee for this specific order, can be set by maker or a default
    uint8 sellDecimals; // To help interpret the price field consistently
    uint256 amountRemaining;
    address sellToken;
    address buyToken;
    uint256 price; // Price of 1 unit of sellToken in terms of buyToken, scaled by 1e18
}
### File: packages/contracts/perps/MarginAccount.sol

### File: packages/contracts/perps/PerpMarket.sol

### File: packages/contracts/perps/libraries/FundingRateLib.sol

### File: packages/contracts/perps/PerpClearingHouse.sol

### File: packages/contracts/perps/PerpsAdmin.sol

### File: packages/contracts/perps/PerpLiquidationEngine.sol

### File: packages/contracts/ethereum/OracleRelayerSrc.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Strings.sol"; // For error messages
import "../interfaces/ILayerZeroEndpoint.sol"; // Assumes ILayerZeroEndpoint.sol is in packages/contracts/interfaces/
import "@chainlink/contracts/src/v0.8/shared/interfaces/AggregatorV3Interface.sol";

/**
 * @title OracleRelayerSrc
 * @author Unxversal Team
 * @notice Relays price data from Chainlink on a source chain (e.g., Polygon)
 *         to a destination chain (Peaq) via LayerZero.
 * @dev Manages Chainlink aggregators, price update thresholds, and LayerZero communication.
 *      The contract expects to be funded with native currency (e.g., MATIC on Polygon)
 *      by keepers to pay for LayerZero messaging fees.
 */
contract OracleRelayerSrc is Ownable, ReentrancyGuard {
    ILayerZeroEndpoint public immutable lzEndpoint;

    uint16 public dstChainId;           // LayerZero chain ID of the destination (Peaq)
    bytes public dstAppAddress;        // OracleRelayerDst address on Peaq (LayerZero packed bytes format)

    struct OracleConfig {
        AggregatorV3Interface aggregator;
        uint256 priceDeviationThresholdBps; // Basis points, e.g., 50 for 0.5%
        uint32 timeUpdateThresholdSec;    // Seconds, e.g., 3600 for 1 hour
        uint256 lastSentPrice;            // Last price sent for this asset
        uint32 lastSentTimestamp;         // Block timestamp when the last price was sent
        bool isActive;                    // Flag to enable/disable updates for this oracle
    }

    mapping(uint256 => OracleConfig) public oracleConfigs; // assetId => OracleConfig
    // To iterate over configured assets if needed by off-chain services (optional)
    uint256[] public configuredAssetIds;
    mapping(uint256 => uint256) private _assetIdToIndex; // For O(1) removal from configuredAssetIds

    bytes public defaultAdapterParams; // Default adapter parameters for LayerZero send

    uint256 public constant BPS_DENOMINATOR = 10000;

    event PriceSent(
        uint256 indexed assetId,
        uint256 price,
        uint32 oracleTimestamp, // Timestamp from Chainlink
        uint16 indexed dstChainId,
        uint256 lzNativeFeePaidByCaller
    );
    event OracleConfigured(
        uint256 indexed assetId,
        address aggregator,
        uint256 priceDeviationThresholdBps,
        uint32 timeUpdateThresholdSec,
        bool isActive
    );
    event OracleActivationChanged(uint256 indexed assetId, bool isActive);
    event DstAppSet(uint16 newDstChainId, bytes newDstAppAddress);
    event DefaultAdapterParamsSet(bytes params);
    event FundsWithdrawn(address indexed to, uint256 amount);

    modifier onlyActiveOracle(uint256 assetId) {
        require(oracleConfigs[assetId].isActive, "ORS: Oracle for assetId is not active");
        _;
    }

    /**
     * @param _lzEndpointAddress The address of the LayerZero Endpoint on the source chain (e.g., Polygon).
     * @param _initialOwner The initial owner (multisig/DAO Timelock) of this contract.
     */
    constructor(address _lzEndpointAddress, address _initialOwner) Ownable(_initialOwner) { // Ownable constructor
        require(_lzEndpointAddress != address(0), "ORS: Zero L0 endpoint");
        lzEndpoint = ILayerZeroEndpoint(_lzEndpointAddress);
        // dstChainId and dstAppAddress must be set later via setDstApp
        // defaultAdapterParams can also be set later
    }

    /**
     * @notice Sets the destination LayerZero chain ID and application address.
     * @dev Only callable by the owner.
     * @param _dstChainId The LayerZero chain ID of the Peaq network.
     * @param _dstAppAddress The address of OracleRelayerDst on Peaq, in LayerZero bytes format.
     */
    function setDstApp(uint16 _dstChainId, bytes calldata _dstAppAddress) external onlyOwner {
        require(_dstChainId != 0, "ORS: Zero dstChainId");
        require(_dstAppAddress.length > 0, "ORS: Empty dstAppAddress");
        dstChainId = _dstChainId;
        dstAppAddress = _dstAppAddress;
        emit DstAppSet(_dstChainId, _dstAppAddress);
    }

    /**
     * @notice Configures or updates an oracle for a specific asset.
     * @dev Only callable by the owner. If assetId is new, it's added.
     * @param assetId The unique identifier for the asset (e.g., keccak256("BTC")).
     * @param aggregatorAddress The address of the Chainlink AggregatorV3Interface.
     * @param priceDeviationThresholdBps Price change (in BPS) from lastSentPrice to trigger an update. (e.g., 50 for 0.5%).
     * @param timeUpdateThresholdSec Time (in seconds) since lastSentTimestamp to trigger an update (e.g., 3600 for 1 hr).
     * @param isActive Sets the oracle to active or inactive. Inactive oracles won't send updates.
     */
    function configureOracle(
        uint256 assetId,
        address aggregatorAddress,
        uint256 priceDeviationThresholdBps,
        uint32 timeUpdateThresholdSec,
        bool isActive
    ) external onlyOwner {
        require(aggregatorAddress != address(0), "ORS: Zero aggregator address");
        require(priceDeviationThresholdBps < BPS_DENOMINATOR, "ORS: Invalid deviation threshold");

        OracleConfig storage config = oracleConfigs[assetId];
        bool isNewAsset = (address(config.aggregator) == address(0));

        config.aggregator = AggregatorV3Interface(aggregatorAddress);
        config.priceDeviationThresholdBps = priceDeviationThresholdBps;
        config.timeUpdateThresholdSec = timeUpdateThresholdSec;
        config.isActive = isActive;
        // lastSentPrice and lastSentTimestamp remain or are 0 if new/reset

        if (isNewAsset) {
            configuredAssetIds.push(assetId);
            _assetIdToIndex[assetId] = configuredAssetIds.length - 1;
        }
        // If re-configuring, index remains. If deactivating then reactivating, it's already tracked.

        emit OracleConfigured(assetId, aggregatorAddress, priceDeviationThresholdBps, timeUpdateThresholdSec, isActive);
    }

    /**
     * @notice Activates or deactivates an existing oracle configuration.
     * @dev Only callable by the owner.
     * @param assetId The assetId of the oracle to modify.
     * @param isActive True to activate, false to deactivate.
     */
    function setOracleActive(uint256 assetId, bool isActive) external onlyOwner {
        OracleConfig storage config = oracleConfigs[assetId];
        require(address(config.aggregator) != address(0), "ORS: Oracle not configured for assetId");
        config.isActive = isActive;
        emit OracleActivationChanged(assetId, isActive);
    }

    // Function to remove an oracle config (optional, consider implications for configuredAssetIds array)
    // function removeOracleConfig(uint256 assetId) external onlyOwner { ... }


    /**
     * @notice Sets the default adapter parameters for LayerZero send calls.
     * @dev Used for specifying gas airdrops or other relayer instructions for `lzReceive` on Peaq.
     *      Example: `abi.encodePacked(uint16(1), uint256(250000))` for version 1, 250k gas airdrop.
     * @param _params The encoded adapter parameters.
     */
    function setDefaultAdapterParams(bytes calldata _params) external onlyOwner {
        // Basic validation: often params start with uint16 version.
        // require(_params.length >= 2, "ORS: Adapter params too short");
        defaultAdapterParams = _params;
        emit DefaultAdapterParamsSet(_params);
    }

    /**
     * @notice Fetches the current price from Chainlink for an asset and sends it via LayerZero if thresholds are met.
     * @dev This function is payable; msg.value is used for LayerZero fees. Called by keepers.
     * @param assetId The assetId to update.
     * @param adapterParams Custom adapter parameters for this send, overrides defaultAdapterParams if provided.
     */
    function updateAndSendPrice(uint256 assetId, bytes calldata adapterParams)
        external
        payable
        nonReentrant
        onlyActiveOracle(assetId)
    {
        require(dstChainId != 0 && dstAppAddress.length > 0, "ORS: Destination not set");

        OracleConfig storage config = oracleConfigs[assetId]; // Already checked for existence by onlyActiveOracle

        // Chainlink data fetching
        (
            /*uint80 roundId*/,
            int256 currentPriceInt,
            /*uint256 startedAt*/,
            uint256 updatedAtChainlinkTimestamp, // This is uint256 from Chainlink
            /*uint80 answeredInRound*/
        ) = config.aggregator.latestRoundData();

        require(currentPriceInt > 0, "ORS: Chainlink price is not positive");
        uint256 currentPrice = uint256(currentPriceInt);
        // Ensure Chainlink timestamp is reasonable; convert to uint32
        require(updatedAtChainlinkTimestamp <= block.timestamp, "ORS: Chainlink timestamp in future");
        require(updatedAtChainlinkTimestamp > 0, "ORS: Chainlink timestamp is zero");
        uint32 currentOracleTimestamp = uint32(updatedAtChainlinkTimestamp);


        bool shouldUpdate = false;
        if (config.lastSentTimestamp == 0) { // First time sending for this config
            shouldUpdate = true;
        } else {
            // Time threshold check (based on last *sent* time)
            if (config.timeUpdateThresholdSec > 0 &&
                (block.timestamp - config.lastSentTimestamp >= config.timeUpdateThresholdSec)) {
                shouldUpdate = true;
            }
            // Price deviation check (based on last *sent* price)
            if (!shouldUpdate && config.priceDeviationThresholdBps > 0 && config.lastSentPrice > 0) {
                uint256 priceDiff = currentPrice > config.lastSentPrice
                    ? currentPrice - config.lastSentPrice
                    : config.lastSentPrice - currentPrice;
                if ((priceDiff * BPS_DENOMINATOR) / config.lastSentPrice >= config.priceDeviationThresholdBps) {
                    shouldUpdate = true;
                }
            }
        }

        if (!shouldUpdate) {
            if (msg.value > 0) { // Refund if no update needed
                payable(msg.sender).transfer(msg.value);
            }
            return;
        }

        // Prepare LayerZero payload: { assetId, price, oracleTimestamp }
        bytes memory payload = abi.encode(assetId, currentPrice, currentOracleTimestamp);
        bytes memory chosenAdapterParams;
        if (adapterParams.length > 0) {
            chosenAdapterParams = adapterParams;          // calldata → memory copy
        } else {
            chosenAdapterParams = defaultAdapterParams;   // storage  → memory copy
        }

        // Estimate LayerZero fees
        (uint256 nativeFee, /*uint256 zroFee*/) = lzEndpoint.estimateFees(
            dstChainId,
            address(this), // This contract is the UA on the source chain
            payload,
            false,         // Pay L0 protocol fee in native currency (e.g., MATIC)
            chosenAdapterParams
        );

        require(msg.value >= nativeFee, string.concat(
                "ORS: Insufficient fee. Provided: ", Strings.toString(msg.value),
                ", Required: ", Strings.toString(nativeFee)
            )
        );

        // Send LayerZero message
        lzEndpoint.send{value: msg.value}(
            dstChainId,
            dstAppAddress,
            payload,
            payable(msg.sender), // Refund address for L0 overpayment of gas specified in msg.value
            address(0x0),        // ZRO payment address (if paying in ZRO, otherwise address(0))
            chosenAdapterParams
        );

        // Update last sent status
        config.lastSentPrice = currentPrice;
        config.lastSentTimestamp = uint32(block.timestamp); // Record our contract's send time

        emit PriceSent(assetId, currentPrice, currentOracleTimestamp, dstChainId, msg.value);
    }

    /**
     * @notice Allows the owner to withdraw any native currency (e.g., MATIC) balance from this contract.
     * @dev Useful for retrieving excess funds not used for LayerZero fees.
     */
    function withdrawNative(address payable _to) external onlyOwner nonReentrant {
        require(_to != address(0), "ORS: Withdraw to zero address");
        uint256 balance = address(this).balance;
        require(balance > 0, "ORS: No balance to withdraw");
        (bool success, ) = _to.call{value: balance}("");
        require(success, "ORS: Native withdrawal failed");
        emit FundsWithdrawn(_to, balance);
    }

    // Fallback function to receive native currency (e.g., ETH, MATIC) for L0 fees
    receive() external payable {}

    // --- View functions for off-chain services ---
    function getConfiguredAssetCount() external view returns (uint256) {
        return configuredAssetIds.length;
    }

    function getOracleConfig(uint256 assetId)
        external
        view
        returns (
            address aggregator,
            uint256 priceDeviationThresholdBps,
            uint32 timeUpdateThresholdSec,
            uint256 lastSentPrice,
            uint32 lastSentTimestamp,
            bool isActive
        )
    {
        OracleConfig storage config = oracleConfigs[assetId];
        return (
            address(config.aggregator),
            config.priceDeviationThresholdBps,
            config.timeUpdateThresholdSec,
            config.lastSentPrice,
            config.lastSentTimestamp,
            config.isActive
        );
    }
}
### File: packages/contracts/interfaces/ILayerZeroEndpoint.sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.19; // Updated pragma for consistency

import "./ILayerZeroUserApplicationConfig.sol"; // Assuming it's in the same directory

interface ILayerZeroEndpoint is ILayerZeroUserApplicationConfig {
    // @notice send a LayerZero message to the specified address at a LayerZero endpoint.
    // @param _dstChainId - the destination chain identifier
    // @param _destination - the address on destination chain (in bytes). address length/format may vary by chains
    // @param _payload - a custom bytes payload to send to the destination contract
    // @param _refundAddress - if the source transaction is cheaper than the amount of value passed, refund the additional amount to this address
    // @param _zroPaymentAddress - the address of the ZRO token holder who would pay for the transaction
    // @param _adapterParams - parameters for custom functionality. e.g. receive airdropped native gas from the relayer on destination
    function send(uint16 _dstChainId, bytes calldata _destination, bytes calldata _payload, address payable _refundAddress, address _zroPaymentAddress, bytes calldata _adapterParams) external payable;

    // @notice used by the messaging library to publish verified payload
    // @param _srcChainId - the source chain identifier
    // @param _srcAddress - the source contract (as bytes) at the source chain
    // @param _dstAddress - the address on destination chain
    // @param _nonce - the unbound message ordering nonce
    // @param _gasLimit - the gas limit for external contract execution
    // @param _payload - verified payload to send to the destination contract
    function receivePayload(uint16 _srcChainId, bytes calldata _srcAddress, address _dstAddress, uint64 _nonce, uint _gasLimit, bytes calldata _payload) external;

    // @notice get the inboundNonce of a receiver from a source chain which could be EVM or non-EVM chain
    // @param _srcChainId - the source chain identifier
    // @param _srcAddress - the source chain contract address
    function getInboundNonce(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (uint64);

    // @notice get the outboundNonce from this source chain which, consequently, is always an EVM
    // @param _srcAddress - the source chain contract address
    function getOutboundNonce(uint16 _dstChainId, address _srcAddress) external view returns (uint64);

    // @notice gets a quote in source native gas, for the amount that send() requires to pay for message delivery
    // @param _dstChainId - the destination chain identifier
    // @param _userApplication - the user app address on this EVM chain
    // @param _payload - the custom message to send over LayerZero
    // @param _payInZRO - if false, user app pays the protocol fee in native token
    // @param _adapterParam - parameters for the adapter service, e.g. send some dust native token to dstChain
    function estimateFees(uint16 _dstChainId, address _userApplication, bytes calldata _payload, bool _payInZRO, bytes calldata _adapterParam) external view returns (uint nativeFee, uint zroFee);

    // @notice get this Endpoint's immutable source identifier
    function getChainId() external view returns (uint16);

    // @notice the interface to retry failed message on this Endpoint destination
    // @param _srcChainId - the source chain identifier
    // @param _srcAddress - the source chain contract address
    // @param _payload - the payload to be retried
    function retryPayload(uint16 _srcChainId, bytes calldata _srcAddress, bytes calldata _payload) external;

    // @notice query if any STORED payload (message blocking) at the endpoint.
    // @param _srcChainId - the source chain identifier
    // @param _srcAddress - the source chain contract address
    function hasStoredPayload(uint16 _srcChainId, bytes calldata _srcAddress) external view returns (bool);

    // @notice query if the _libraryAddress is valid for sending msgs.
    // @param _userApplication - the user app address on this EVM chain
    function getSendLibraryAddress(address _userApplication) external view returns (address);

    // @notice query if the _libraryAddress is valid for receiving msgs.
    // @param _userApplication - the user app address on this EVM chain
    function getReceiveLibraryAddress(address _userApplication) external view returns (address);

    // @notice query if the non-reentrancy guard for send() is on
    // @return true if the guard is on. false otherwise
    function isSendingPayload() external view returns (bool);

    // @notice query if the non-reentrancy guard for receive() is on
    // @return true if the guard is on. false otherwise
    function isReceivingPayload() external view returns (bool);

    // @notice get the configuration of the LayerZero messaging library of the specified version
    // @param _version - messaging library version
    // @param _chainId - the chainId for the pending config change
    // @param _userApplication - the contract address of the user application
    // @param _configType - type of configuration. every messaging library has its own convention.
    function getConfig(uint16 _version, uint16 _chainId, address _userApplication, uint _configType) external view returns (bytes memory);

    // @notice get the send() LayerZero messaging library version
    // @param _userApplication - the contract address of the user application
    function getSendVersion(address _userApplication) external view returns (uint16);

    // @notice get the lzReceive() LayerZero messaging library version
    // @param _userApplication - the contract address of the user application
    function getReceiveVersion(address _userApplication) external view returns (uint16);
}
### File: packages/contracts/interfaces/IPermit2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import {
    PermitBatchTransferFrom,
    SignatureTransferDetails,
    PermitTransferFrom
} from "./structs/SPermit2.sol"; // Adjust path if SPermit2.sol is elsewhere

interface IPermit2 {
    function permitTransferFrom(
        PermitBatchTransferFrom memory permit,
        SignatureTransferDetails[] calldata transferDetails,
        address owner,
        bytes calldata signature
    ) external;

    function permitTransferFrom(
        PermitTransferFrom memory permit,
        SignatureTransferDetails calldata transferDetails,
        address owner,
        bytes calldata signature
    ) external;
}
### File: packages/contracts/interfaces/structs/SPermit2.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

struct TokenPermissions {
    address token;
    uint256 amount;
}

struct PermitTransferFrom {
    TokenPermissions permitted;
    uint256 nonce;
    uint256 deadline;
}

struct SignatureTransferDetails {
    address to;
    uint256 requestedAmount;
}

struct PermitBatchTransferFrom {
    TokenPermissions[] permitted;
    uint256 nonce;
    uint256 deadline;
}
### File: packages/contracts/interfaces/ILayerZeroReceiver.sol
// SPDX-License-Identifier: MIT

pragma solidity >=0.5.0;

interface ILayerZeroReceiver {
    // @notice LayerZero endpoint will invoke this function to deliver the message on the destination
    // @param _srcChainId - the source endpoint identifier
    // @param _srcAddress - the source sending contract address from the source chain
    // @param _nonce - the ordered message nonce
    // @param _payload - the signed payload is the UA bytes has encoded to be sent
    function lzReceive(
        uint16 _srcChainId,
        bytes calldata _srcAddress,
        uint64 _nonce,
        bytes calldata _payload
    ) external;
}
### File: packages/contracts/interfaces/ILayerZeroUserApplicationConfig.sol
// SPDX-License-Identifier: BUSL-1.1
pragma solidity ^0.8.19; // Updated pragma for consistency

interface ILayerZeroUserApplicationConfig {
    // @notice set the configuration of the LayerZero messaging library of the specified version
    // @param _version - messaging library version
    // @param _chainId - the chainId for the pending config change
    // @param _configType - type of configuration. every messaging library has its own convention.
    // @param _config - configuration in the bytes. can encode arbitrary content.
    function setConfig(uint16 _version, uint16 _chainId, uint _configType, bytes calldata _config) external;

    // @notice set the send() LayerZero messaging library version to _version
    // @param _version - new messaging library version
    function setSendVersion(uint16 _version) external;

    // @notice set the lzReceive() LayerZero messaging library version to _version
    // @param _version - new messaging library version
    function setReceiveVersion(uint16 _version) external;

    // @notice Only when the UA needs to resume the message flow in blocking mode and clear the stored payload
    // @param _srcChainId - the chainId of the source chain
    // @param _srcAddress - the contract address of the source contract at the source chain
    function forceResumeReceive(uint16 _srcChainId, bytes calldata _srcAddress) external;
}
### File: hardhat.config.ts
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";

const config: HardhatUserConfig = {
  solidity: "0.8.28",
};

export default config;

